% Este trabalho está licenciado sob a Licença Atribuição-CompartilhaIgual 4.0 Internacional Creative Commons. Para visualizar uma cópia desta licença, visite http://creativecommons.org/licenses/by-sa/4.0/deed.pt_BR ou mande uma carta para Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

\chapter{Arranjos e Matrizes}\label{cap_arr}

\hl{Um arranjo é uma coleção de objetos} (todos de um mesmo tipo) \hl{em que os elementos são organizados por eixos}. É a estrutura de dados mais utilizada para a alocação de vetores e matrizes, fundamentais na computação matricial.

\section{Arranjos}\label{cap_arr_sec_arr}

\hl{Um arranjo (em inglês, \textit{array}) é uma coleção de objetos (todos do mesmo tipo) em que os elementos são organizados por eixos}. Nesta seção, vamos nos restringir a \hl{\emph{arranjos unidimensionais}} (de apenas um eixo). Esta é a estrutura computacionais usualmente utilizada \hl{para a alocação de vetores}.

\hl{{\numpy} é uma biblioteca {\python} que fornece suporte para a alocação e manipulação de arranjos}. Usualmente, a biblioteca é importada como segue

\begin{lstlisting}
import numpy as np
\end{lstlisting}

Na sequência, vamos assumir que o {\numpy} já está importado como acima.

\subsection{Alocação de Arranjos}

O método {\PYTHONnumpyDOTarray} permite a \hl{alocação de um arranjo}. Como parâmetro de entrada, recebe uma {\PYTHONlist} contendo os elementos do arranjo. Por exemplo,

\begin{lstlisting}
>>> v = np.array([-2, 1, 3])
>>> v
array([-2,  1,  3])
>>> type(v)
<class 'numpy.ndarray'>
\end{lstlisting}

aloca o arranjo de números inteiros \lstinline+v+. Embora arranjos não sejam vetores, \hl{a modelagem computacional de vetores usualmente é feita utilizando-se} \texttt{arrays}. Por exemplo, em um código {\python}, o vetor
\begin{equation}
  \pmb{v} = (-2, 1, 3)
\end{equation}
pode ser alocado usando-se o \texttt{array} \lstinline+v+ acima.

O \hl{tipo dos dados} de um \lstinline+array+ é definido na sua criação. Pode ser feita de forma automática ou explícita pela propriedade {\PYTHONnumpyDOTdtype}. Por exemplo,

\begin{lstlisting}
>>> v = np.array([-2, 1, 3])
>>> v.dtype
dtype('int64')
>>> v = np.array([-2., 1, 3])
>>> v.dtype
dtype('float64')
>>> v = np.array([-2, 1, 3], dtype='float')
>>> v.dtype
dtype('float64')
\end{lstlisting}

\begin{ex}
  Aloque o vetor
  \begin{equation}
    \pmb{v} = (\pi, 1, e)
  \end{equation}
  como um \lstinline+array+ do {\numpy}.

\begin{lstlisting}
>>> import numpy as np
>>> v = np.array([np.pi, 1, np.e])
>>> v
array([3.14159265, 1.        , 2.71828183])
\end{lstlisting}

\end{ex}

O {\numpy} conta com \hl{métodos úteis para a \emph{inicialização}} de \texttt{arrays}:
\begin{itemize}
\item {\PYTHONnumpyDOTzeros} \hlemph{arranjo de elementos nulos}

\begin{lstlisting}[xrightmargin=2.5em]
>>> np.zeros(3)
array([0., 0., 0.])
\end{lstlisting}

\item {\PYTHONnumpyDOTones} \hlemph{arranjo de elementos iguais a um}

\begin{lstlisting}[xrightmargin=2.5em]
>>> np.ones(2, dtype='int')
array([1, 1])
\end{lstlisting}

\item {\PYTHONnumpyDOTempty} \hlemph{arranjo de elementos não predefinidos}

\begin{lstlisting}[xrightmargin=2.5em]
>>> np.empty(3)
array([4.64404327e-310, 0.00000000e+000, 6.93315702e-310])
\end{lstlisting}

\item {\PYTHONnumpyDOTlinspace}\texttt{(start, stop, num=50)} \emph{\hl{arranjo de elementos uniformemente espaçados}}

\begin{lstlisting}[xrightmargin=2.5em]
>>> np.linspace(0, 1, 5)
array([0.  , 0.25, 0.5 , 0.75, 1.  ])
\end{lstlisting}
\end{itemize}

\subsection{Indexação e Fatiamento}\label{cap_arr_sec_arr:ssec:islice}

Um {\PYTHONnumpyDOTarray} é uma \hl{coleção de objetos mutável, ordenada e indexada}. Indexação e fatiamento podem ser feitos da mesma forma que para um {\PYTHONtuple} ou uma {\PYTHONlist}. Por exemplo,

\begin{lstlisting}
>>> v = np.array([-1, 1, 2, 0, 3])
>>> v[0]
-1
>>> v[-1]
3
>>> v[1:4]
array([1, 2, 0])
>>> v[::-1]
array([ 3,  0,  2,  1, -1])
>>> v[3] = 4
>>> v
array([-1,  1,  2,  4,  3])
\end{lstlisting}

\subsection{Reordenamento dos Elementos}

Em programação, o reordenamento (em inglês, \textit{sorting}) de elementos de uma sequência ordenada de números (\texttt{array}, \texttt{tuple}, \texttt{tuple}, etc.) consiste em alterar a sequência de forma que os elementos sejam organizados do menor para o mair valor. Na sequência, vamos estudar alguns métodos para isso.

\subsubsection{Método Bolha}

Dado um {\PYTHONnumpyDOTarray}\endnote{Ou, um {\PYTHONtuple}, {\PYTHONlist}, etc..}, o método bolha consiste em percorrer o arranjo e permutar dois elementos consecutivos de forma que o segundo seja sempre maior que o primeiro. Uma vez que percorrermos o arranjo, teremos garantido que o maior valor estará na última posição do arranjo e os demais elementos ainda poderão estar desordenados. Então, percorremos o arranjo novamente, permutando elementos dois-a-dois conforme a ordem desejada, o que trará o segundo maior elemento para a penúltima posição. Ou seja, para um arranjo com $n$ elementos, temos garantido o reordenamento de todos os elementos após $n-1$ repetições desse algoritmo.

\begin{ex}
  Na sequência, implementamos o Método Bolha para o reordenamento de arranjos e aplicamos para
  \begin{equation}
    \pmb{v} = (-1, 1, 0, 4, 3).
  \end{equation}
  
\begin{lstlisting}[caption=bubbleSort\_v1.py]
import numpy as np

def bubbleSort(arr):
    arr = arr.copy()
    n = len(arr)
    for k in range(n-1):
        for i in range(n-k-1):
            if (arr[i] > arr[i+1]):
                arr[i], arr[i+1] = arr[i+1], arr[i]
    return arr

v = np.array([-1,1,0,4,3])
w = bubbleSort(v)
print(w)
\end{lstlisting}

\end{ex}

\begin{obs}
  Em geral, para um arranjo de $n$ elementos, o Método Bolha requer $n-1$ repetições para completar o ordenamento. Entretanto, dependendo do caso, o ordenamento dos elementos pode terminar em menos passos.
\end{obs}

\begin{ex}
  Na sequência, implementamos uma nova versão do Método Bolha para o reordenamento de arranjos. Esta versão verifica se há elementos fora de ordem e, caso não haja, interrompe o algoritmo. Como exemplo, aplicamos para
  \begin{equation}
    \pmb{v} = (-1, 1, 0, 4, 3).
  \end{equation}
  
\begin{lstlisting}[caption=bubbleSort\_v2.py]
import numpy as np

def bubbleSort(arr):
    arr = arr.copy()
    n = len(arr)
    for k in range(n-1):
        noUpdated = True
        for i in range(n-k-1):
            if (arr[i] > arr[i+1]):
                arr[i], arr[i+1] = arr[i+1], arr[i]
                noUpdated = False
        if (noUpdated):
            break
    return arr

v = np.array([-1,1,0,4,3])
w = bubbleSort(v)
\end{lstlisting}

\end{ex}

\begin{obs}\normalfont{(\hl{Métodos de Ordenamento}.)}
  Existem vários métodos para o ordenamento de uma sequência. O Método Bolha é um dos mais simples, mas também, em geral, menos eficiente. O {\numpy} tem disponível a função {\PYTHONnumpyDOTsort} para o reordenamento de elementos. Também bastante útil, é a função {\PYTHONnumpyDOTargsort}, que retorna os índices que reordenam os elementos.
\end{obs}

\subsection{Operações Elemento-a-Elemento}

No {\numpy}, temos os \hlemph{operadores aritméticos elemento-a-elemento} (em ordem de precedência)
\begin{itemize}
\item \lstinline!**!

\begin{lstlisting}[xrightmargin=2.5em]
>>> v = np.array([-2., 1, 3])
>>> w = np.array([1., -1, 2])
>>> v ** w
array([-2.,  1.,  9.])
\end{lstlisting}

\item \lstinline!*!, \lstinline!/!, \lstinline!//!, \lstinline!%!

\begin{lstlisting}[xrightmargin=2.5em]
>>> v * w
array([-2., -1.,  6.])
>>> v / w
array([-2. , -1. ,  1.5])
>>> v // w
array([-2., -1.,  1.])
>>> v % w
array([ 0., -0.,  1.])
\end{lstlisting}

\item \lstinline!+!, \lstinline!-!

\begin{lstlisting}[xrightmargin=2.5em]
>>> v + w
array([-1.,  0.,  5.])
>>> v - w
array([-3.,  2.,  1.])
\end{lstlisting}

\end{itemize}

\begin{ex}
  Vamos usar \texttt{arrays} para alocar os vetores
  \begin{align}
    \pmb{v} = (1., 0, -2),\\
    \pmb{w} = (2., -1, 3).
  \end{align}
  Então, computamos o produto interno
  \begin{subequations}
    \begin{align}
      \pmb{v}\cdot\pmb{w} &:= v_1w_1 + v_2w_2 + v_3w_3\\
                          &= 1\cdot 2 + 0\cdot(-1) + (-2)\cdot 3\\
                          &= -4.
    \end{align}
  \end{subequations}

\begin{lstlisting}
import numpy as np
# vetores
v = np.array([1., 0, -2])
w = np.array([2., -1, 3])
# produto interno
vdw = np.sum(v*w)
\end{lstlisting}

\end{ex}

\begin{obs}\normalfont{(\hl{Concatenação de Arranjos}.)}
  No {\numpy}, a concatenação de arranjos pode ser feita com a função {\PYTHONnumpyDOTconcatenate}. Por exemplo,

\begin{lstlisting}
>>> v = np.array([1,2])
>>> w = np.array([3,4])
>>> np.concatenate((v,w))
array([1, 2, 3, 4])
\end{lstlisting}

\end{obs}

\subsection{Exercícios}

\begin{exer}
  Aloque cada um dos seguintes vetores como um {\PYTHONnumpyDOTarray}:
  \begin{enumerate}[a)]
  \item $\displaystyle\pmb{a} = (0, -2, 4)$
  \item $\displaystyle\pmb{b} = (0.1, -2.7, 4.5)$
  \item $\displaystyle\pmb{c} = (e, \ln(2), \pi)$
  \end{enumerate}
\end{exer}
\begin{resp}

\begin{lstlisting}
>>> import numpy as np
>>> a = np.array([0, -2, 4])
>>> b = np.array([0.1, -2.7, 4.5])
>>> c = np.array([np.e, np.log(2), np.pi])
\end{lstlisting}

\end{resp}

\begin{exer}
  Considere o seguinte {\PYTHONnumpyDOTarray}

\begin{lstlisting}
>>> v = np.array([4, -1, 1, -2, 3]).
\end{lstlisting}

Sem implementar, escreva os arranjos derivados:
  \begin{enumerate}[a)]
  \item \lstinline+v[1]+
  \item \lstinline+v[1:4]+
  \item \lstinline+v[:3]+
  \item \lstinline+v[1:]+
  \item \lstinline+v[1:4:2]+
  \item \lstinline+v[-2:-5:-1]+
  \item \lstinline+v[::-2]+
  \end{enumerate}
  Então, verifique seus resultados implementando-os.
\end{exer}
\begin{resp}
  Dica: consulte a Subseção \ref{cap_arr_sec_arr:ssec:islice}. 
\end{resp}

\begin{exer}
  Desenvolva uma função \lstinline+argBubbleSort(arr)+, i.e. uma função que retorna os índices que reordenam os elementos do arranjo \lstinline+arr+ em ordem crescente. Teste seu código para o ordenamento de diversos arranjos e compare os resultados com a aplicação da função {\PYTHONnumpyDOTargsort}.
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np

def argBubbleSort(arr):
    n = len(arr)
    ind = np.arange(n)
    for k in range(n-1):
        noUpdated = True
        for i in range(n-k-1):
            if (arr[ind[i]] > arr[ind[i+1]]):
                ind[i], ind[i+1] = ind[i+1], ind[i]
                noUpdated = False
        if (noUpdated):
            break
    return ind
\end{lstlisting}

\end{resp}

\begin{exer}
  Desenvolva um Método Bolha para o reordenamento dos elementos de um dado arranjo em ordem decrescente. Teste seu código para o reordenamento de diversos arranjos. Como pode-se usar a função {\PYTHONnumpyDOTsort} para obter os mesmos resultados?
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np

def emOrdem(x, y):
    return x < y

def bubbleSort(arr, emOrdem=emOrdem):
    arr = arr.copy()
    n = len(arr)
    for k in range(n-1):
        noUpdated = True
        for i in range(n-k-1):
            if not(emOrdem(arr[i], arr[i+1])):
                arr[i], arr[i+1] = arr[i+1], arr[i]
                noUpdated = False
        if (noUpdated):
            break
    return arr
\end{lstlisting}

\end{resp}

\begin{exer}
  Desenvolva uma função \lstinline+argBubbleSort(arr, emOrdem)+, i.e. uma função que retorna os índices que reordenam os elementos do arranjo \lstinline+arr+ na ordem definida pela função \lstinline+emOrdem+. Teste seu código para o ordenamento de diversos arranjos, tanto em ordem crescente como em ordem decrescente. Como pode-se obter os mesmos resultados usando-se a função {\PYTHONnumpyDOTargsort}?
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np

def argBubbleSort(arr, emOrdem=emOrdem):
    n = len(arr)
    ind = np.arange(n)
    for k in range(n-1):
        noUpdated = True
        for i in range(n-k-1):
            if not(emOrdem(arr[ind[i]], arr[ind[i+1]])):
                ind[i], ind[i+1] = ind[i+1], ind[i]
                noUpdated = False
        if (noUpdated):
            break
    return ind
\end{lstlisting}

\end{resp}

\begin{exer}
  Implemente uma função \lstinline+media(arr)+ que returna o valor médio do arranjo de números \lstinline+arr+. Teste seu código para diferentes arranjos e compare os resultados com o da função {\PYTHONnumpyDOTmean}.
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np

def media(arr):
    return np.sum(arr)/arr.size
\end{lstlisting}

\end{resp}

\begin{exer}
  Desenvolva uma função que retorna o ângulo entre dois vetores $\pmb{v}$ e $\pmb{w}$ dados.
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np

def dot(v, w):
    return np.sum(v*w)

def angulo(v, w):
    # norma de v
    norm_v = np.sqrt(dot(v,v))
    # norma de w
    norm_w = np.sqrt(dot(w,w))
    # cos(theta)
    cosTheta = dot(v,w)/(norm_v*norm_w)
    # theta
    theta = np.acos(cosTheta)
    return theta
\end{lstlisting}

\end{resp}

\ifisbook
\subsubsection{Respostas}
\shipoutAnswer
\fi


\section{Vetores}\label{cap_arr_sec_vetor}

O uso de \texttt{arrays} é uma das formas mais adequadas para fazermos a \hl{modelagem computacional de \emph{vetores}}. Entretanto, devemos ficar atentos que \hl{vetores e arranjos não são equivalentes}. Embora, a soma/subtração e multiplicação por escalar são similares, a multiplicação e potenciação envolvendo vetores não estão definidas, mas para arranjos são operações elemento-a-elemento.

No que segue, vamos assumir que a biblioteca {\numpy} está importada, i.e.

\begin{lstlisting}
>>> import numpy as np
\end{lstlisting}

\begin{ex}
  Podemos alocar os vetores
  \begin{align}
    &\pmb{v} = (1, 0, -2),\\
    &\pmb{w} = (2, -1, 3),
  \end{align}
  como \texttt{arrays} do {\numpy}

\begin{lstlisting}
>>> v = np.array([1, 0, -2])
>>> w = np.array([2, -1, 3])
\end{lstlisting}

  A soma dos vetores é uma operação elemento-a-elemento
  \begin{subequations}
    \begin{align}
      \pmb{v}+\pmb{w} &= (1, 0, -2) + (2, -1, 3)\\
                      &= \left(1+2, 0+(-1), -2+3\right)\\
                      &= (3, -1, 1)
    \end{align}
  \end{subequations}
  e a dos \texttt{arrays} é equivalente

\begin{lstlisting}
>>> v+w
array([ 3, -1,  1])
\end{lstlisting}

  A subtração dos vetores também é uma operação elemento-a-elemento
  \begin{subequations}
    \begin{align}
      \pmb{v}-\pmb{w} &= (1, 0, -2) - (2, -1, 3)\\
                      &= \left(1-2, 0-(-1), -2-3\right)\\
                      &= (-1, 1, -5)
    \end{align}
  \end{subequations}
  e a dos \texttt{arrays} é equivalente

\begin{lstlisting}
>>> v-w
array([ -1, 1,  -5])
\end{lstlisting}

  Ainda, a multiplicação por escalar
  \begin{subequations}
    \begin{align}
      2\pmb{v} &= 2(1, 0, -2)\\
               &= \left(2\cdot 1, 2\cdot 0, 2\cdot(-2)\right)\\
               &= (2, 0, -4)
    \end{align}
  \end{subequations}
  também é feita elemento-a-elemento, assim como com \texttt{arrays}

\begin{lstlisting}
>>> 2*v
array([ 2,  0, -4])
\end{lstlisting}

  Agora, para vetores, a multiplicação $\pmb{v}\pmb{w}$, divisão $\pmb{v}/\pmb{w}$, potenciação $\pmb{v}^2$ não são operações definidas. Diferentemente, para arranjos são operações elemento-a-elemento

\begin{lstlisting}
>>> v*w
array([ 2,  0, -6])
>>> v/w
array([ 0.5, -0., -0.66666667])
>>> v**2
array([1, 0, 4])
\end{lstlisting}

\end{ex}

\subsection{Funções Vetoriais}

Funções vetoriais $f:\mathbb{R}^n\to\mathbb{R}^n$ e funcionais $f:\mathbb{R}^n\to\mathbb{R}$ também podem ser adequadamente modeladas com o emprego de \texttt{arrays} do \hl{{\numpy}}. A biblioteca também \hl{conta com várias funções matemáticas predefinidas}, consulte
\begin{center}
  \url{https://numpy.org/doc/stable/reference/routines.math.html}
\end{center}

\begin{ex}\normalfont{(\hl{Função Vetorial}.)}
  A implementação da função vetorial $\pmb{f}:\mathbb{R}^3\to\mathbb{R}^3$
  \begin{equation}
    \pmb{f}(\pmb{x}) = (x_1^2+\sin(x_1), x_2^2+\sin(x_2), x_3^2+\sin(x_3))
  \end{equation}
  para $\pmb{x} = (x_1, x_2, x_3)\in\mathbb{R}^3$, pode ser feita da seguinte forma

\begin{lstlisting}
import numpy as np

def f(x):
    return x**2 + np.sin(x)

# exemplo
x = np.array([0, np.pi, np.pi/2])
print(f'y = {f(x)}')
\end{lstlisting}

Verifique!
\end{ex}

\subsection{Produto Interno}

O \hlemph{produto interno} (ou, produto escalar) é a operação entre vetores $\pmb{v},\pmb{w}\in\mathbb{R}^n$ definida por
\begin{equation}
  \pmb{v}\cdot\pmb{w} := v_1w_1+v_2w_2+\cdots+v_nw_n.
\end{equation}
A função {\PYTHONnumpyDOTdot} computa o produto interno dos \texttt{arrays}.

\begin{ex}
  Consideramos os vetores
  \begin{align}
    &\pmb{v} = (1, 0, -2),\\
    &\pmb{w} = (2, -1, 3).
  \end{align}
  O produto interno desses vetores é
  \begin{subequations}
    \begin{align}
    \pmb{v}\cdot\pmb{w} &= v_1w_1 + v_2w_2 + v_3w_3\\
                        &= 1\cdot 2 + 0\cdot(-1) + (-2)\cdot 3\\
                        &= 2 + 0 -6 = -4
    \end{align}
  \end{subequations}
  Usando \texttt{arrays}, temos

\begin{lstlisting}
>>> v = np.array([1, 0, -2])
>>> w = np.array([2, -1, 3])
>>> np.sum(v*w)
-4
>>> np.dot(v,w)
-4
\end{lstlisting}

\end{ex}

\subsection{Norma de Vetores}

A \hl{\emph{norma} $L^2$ de um vetor} $\pmb{v}\in\mathbb{R}^n$ é definida por
\begin{equation}
  \|\pmb{v}\| := \sqrt{v_1^2+v_2^2+\cdots+v_n^2}
\end{equation}
O \hl{submódulo de álgebra linear} {\PYTHONnumpyDOTlinalg} contém a função {\PYTHONnumpyDOTlinalgDOTnorm} para a computação da norma de \texttt{arrays}.

\begin{ex}
  A norma do vetor $\pmb{v} = (3, 0, -4)$ é
  \begin{subequations}
    \begin{align}
      \|\pmb{v}\| &= \sqrt{v_1^2 + v_2^2 + v_3^2}\\
                  &= \sqrt{3^2 + 0^2 + (-4)^2}\\
                  &= \sqrt{9 + 0 + 16}\\
                  &= \sqrt{25} = 5.
    \end{align}
  \end{subequations}
  Usando o módulo {\PYTHONnumpyDOTlinalg}, obtemos

\begin{lstlisting}
>>> import numpy as np
>>> import numpy.linalg as npla
>>> v = np.array([3, 0, -4])
>>> np.sqrt(np.dot(v,v))
5.0
>>> npla.norm(v)
5.0
\end{lstlisting}

\end{ex}

\subsection{Produto Vetorial}

O \hl{\emph{produto vetorial}} entre dois vetores $\pmb{v}, \pmb{w}\in\mathbb{R}^3$ é definido por
\begin{subequations}
  \begin{align}
    \pmb{v}\times\pmb{w} &:=
                           \begin{vmatrix}
                             \pmb{i} & \pmb{j} & \pmb{k}\\
                             v_1 & v_2 & v_3\\
                             w_1 & w_2 & w_3
                           \end{vmatrix}\\
                         &=
                           \begin{vmatrix}
                             v_2 & v_3\\
                             w_2 & w_3
                           \end{vmatrix}\pmb{i}\\
                         &- \begin{vmatrix}
                             v_1 & v_3\\
                             w_1 & w_3
                           \end{vmatrix}\pmb{j}\\
                         &+ \begin{vmatrix}
                             v_1 & v_2\\
                             w_1 & w_2
                           \end{vmatrix}\pmb{k}\\
  \end{align}
\end{subequations}
A função {\PYTHONnumpyDOTcross} computa o \hl{produto vetorial} entre \texttt{arrays} (unidimensionais de 3 elementos).

\begin{ex}
  O produto vetorial entre os vetores $\pmb{v} = (1, -2, 1)$ e $\pmb{w} = (0, 2, -1)$ é
  \begin{subequations}
    \begin{align}
      \pmb{v}\times \pmb{w} &=
                              \begin{vmatrix}
                                \pmb{i} & \pmb{j} & \pmb{k}\\
                                1 & -2 & 1\\
                                0 & 2 & -1
                              \end{vmatrix}\\
                            &= 0\pmb{i} + \pmb{j} + 2\pmb{k}\\
                            &= (0, 1, 2).
    \end{align}
  \end{subequations}
    Com o {\numpy}, temos

\begin{lstlisting}
>>> v = np.array([1, -2, 1])
>>> w = np.array([0, 2, -1])
>>> np.cross(v,w)
array([0, 1, 2])
\end{lstlisting}

\end{ex}

\subsection{Exercícios}

\begin{exer}
  Considere os seguintes vetores
  \begin{align}
    &\pmb{u} = (2, -1, 1)\\
    &\pmb{v} = (1, -3, 2)\\
    &\pmb{w} = (-2, -1, -3)
  \end{align}
  Usando \texttt{arrays} do {\numpy}, compute:
  \begin{enumerate}[a)]
  \item $\pmb{u}\cdot\pmb{v}$
  \item $\pmb{u}\cdot (2\pmb{v})$
  \item $\pmb{u}\cdot (\pmb{w} + \pmb{v})$
  \item $\pmb{v}\cdot (\pmb{v} - 2\pmb{u})$
  \end{enumerate}
\end{exer}
\begin{resp}
  Dica: use a função $np.dot()$ e verifique as computações calculando os resultados esperados.
\end{resp}

\begin{exer}
  Considere os seguintes vetores
  \begin{align}
    &\pmb{u} = (2, -1, 1)\\
    &\pmb{v} = (1, -3, 2)\\
    &\pmb{w} = (-2, -1, -3)
  \end{align}
  Usando \texttt{arrays} do {\numpy}, compute:
  \begin{enumerate}[a)]
  \item $\|\pmb{u}\|$
  \item $\|\pmb{u} + \pmb{v}\|$
  \item $|\pmb{u}\cdot \pmb{w}|$
  \end{enumerate}
\end{exer}
\begin{resp}
  Dica: use a função {\PYTHONnumpyDOTlinalgDOTnorm} e verifique as computações calculando os resultados esperados.
\end{resp}

\begin{exer}
  Dados vetores $\pmb{u}$ e $\pmb{v}$, temos que
  \begin{equation}
    \pmb{u}\cdot\pmb{v} = \|\pmb{u}\|\|\pmb{v}\|\cos\theta,
  \end{equation}
  onde $\theta$ é o ângulo entre esses vetores. Implemente uma função que recebe dois vetores e retorna o ângulo entre eles. Teste seu código para diferentes vetores.
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np
import numpy.linalg as npla

def angulo(v, w):
    # \|v\|
    norm_v = npla.norm(v)
    # \|w\|
    norm_w = npla.norm(w)
    # u.v
    vdw = np.dot(v, w)
    # cos \theta
    ct = norm_v*norm_w/udw
    return np.acos(ct)
\end{lstlisting}

\end{resp}

\begin{exer}
  A projeção ortogonal do vetor $\pmb{u}$ na direção do vetor $\pmb{v}$ é definida por
  \begin{equation}
    \proj_{\pmb{v}} \pmb{u} := \frac{\pmb{u}\cdot\pmb{v}}{\|\pmb{v}\|^2}\pmb{v}.
  \end{equation}
  Implemente uma função que recebe dois vetores $\pmb{u}$, $\pmb{v}$ e retorne a projeção de $\pmb{u}$ na direção de $\pmb{v}$. Teste seu código para diferentes vetores.
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np
import numpy.linalg as npla

def proj(u, v):
    # \|v\|
    norm_v = npla.norm(v)
    # u.v
    udv = np.dot(u, v)
    # proj_v u
    proj_vu = udv/norm_v**2 * v
    return proj_vu
\end{lstlisting}

\end{resp}

\begin{exer}
  Considere os vetores
  \begin{align}
    &\pmb{u} = (2, -3, 1),\\
    &\pmb{v} = (1, -2, -1).
  \end{align}
  Usando \texttt{arrays} do {\numpy}, compute os seguintes produtos vetoriais:
  \begin{enumerate}[a)]
  \item $\pmb{u}\times\pmb{v}$
  \item $\pmb{v}\times (2\pmb{v})$
  \end{enumerate}
\end{exer}
\begin{resp}
  Dica: use a função {\PYTHONnumpyDOTcross} e verifique as computações calculando os resultados esperados.
\end{resp}

\ifisbook
\subsubsection{Respostas}
\shipoutAnswer
\fi

\section{Arranjos Multidimensionais}\label{cap_arr_sec_multi}

\hl{Um arranjo {\PYTHONnumpyDOTarray} é um tabelamento de elementos de um mesmo tipo}. Os elementos são organizados por eixos indexados (em inglês, \textit{axes}). Enquanto que nas seções anteriores nos restringimos a \texttt{arrays} unidimensionais (de apenas um eixo), aqui, vamos estudar a alocação e manipulação de arranjos de vários eixos.

\subsection{Alocação, Indexação e Fatiamento}

A \hlemph{alocação} de um {\PYTHONnumpyDOTarray} com mais de um eixo pode ser feita usando-se de \hlemph{listas encadeadas}. Por exemplo,

\begin{lstlisting}
>>> import numpy as np
>>> a = np.array([[1,2,3],[4,5,6]])
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
\end{lstlisting}

cria o arranjo \lstinline+a+ de dois eixos, enquanto

\begin{lstlisting}
>>> b = np.array([[[1,2],[3,4]],[[-1,-2],[-3,-4]]])
>>> b
array([[[ 1,  2],
        [ 3,  4]],

       [[-1, -2],
        [-3, -4]]])
\end{lstlisting}

cria o arranjo \lstinline+b+ de três eixos. Para fazer um paralelo com a matemática, o arranjo \lstinline+a+ é similar (mas, não equivalente) a matriz $A = [a_{i,j}]_{i,j=1}^{2,3}$
\begin{equation}
  A =
  \begin{bmatrix}
    1 & 2 & 3\\
    4 & 5 & 6
  \end{bmatrix},
\end{equation}
e o arranjo \lstinline+b+ é similar (mas, não equivalente) ao tensor $B = [b_{i,j,k}]_{i,j,k=1}^{2,2,2}$.

A propriedade \lstinline+.shape+ é um {\PYTHONtuple} contendo o \hl{tamanho de cada eixo}. Por exemplo,

\begin{lstlisting}
>>> a.shape
(2, 3)
>>> a.shape[0]
2
>>> a.shape[1]
3
\end{lstlisting}

informa que \lstinline+a+ tem dois eixos, o primeiro com tamanho $2$ e o segundo com tamanho $3$. Um paralelo com matrizes, dizemos que \lstinline+a+ tem duas linhas e três colunas. No caso do arranjo \lstinline+b+, temos

\begin{lstlisting}
>>> b.shape
(2, 2, 2)
>>> b.shape[2]
2
\end{lstlisting}

o que nos informa tratar-se de um \lstinline+array+ de três eixos, cada um com tamanho $2$.

O número total de elementos de um \lstinline+array+ pode ser obtido do atributo {\PYTHONnumpyDOTndarrayDOTsize}. Por exemplo,

\begin{lstlisting}
a.size, b.size
\end{lstlisting}

\begin{verbatim}
(6, 8)
\end{verbatim}

\hl{Os elementos em um arranjo são \emph{indexados por eixos} e o \emph{fatiamento} também pode ser feito por eixos}. Por exemplo,

\begin{lstlisting}
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
>>> a[1,0]
4
>>> a[0]
array([1, 2, 3])
>>> a[:,1]
array([2, 5])
>>> a[:,2:]
array([[3],
       [6]])
>>> a[1,::-1]
array([6, 5, 4])
\end{lstlisting}

No caso do arranjo \lstinline+b+ de três eixos, temos

\begin{lstlisting}
>>> b
array([[[ 1,  2],
        [ 3,  4]],

       [[-1, -2],
        [-3, -4]]])
>>> b[1,1,0]
-3
>>> b[0,1]
array([3, 4])
>>> b[1,0,::-1]
array([-2, -1])
\end{lstlisting}

\subsection{Inicialização}

O {\numpy} conta com várias funções para a inicialização de \texttt{arrays}, algumas das mais usadas são:
\begin{itemize}
\item {\PYTHONnumpyDOTzeros} \hlemph{inicialização com zeros}

\begin{lstlisting}[xrightmargin=2.5em]
>>> np.zeros((2,3))
array([[0., 0., 0.],
       [0., 0., 0.]])
\end{lstlisting}

\item {\PYTHONnumpyDOTones} \hlemph{inicialização com uns}

\begin{lstlisting}[xrightmargin=2.5em]
>>> np.ones((2,3,2))
array([[[1., 1.],
        [1., 1.],
        [1., 1.]],

       [[1., 1.],
        [1., 1.],
        [1., 1.]]])
\end{lstlisting}

\item {\PYTHONnumpyDOTempty} \hlemph{inicialização com valor da memória}

\begin{lstlisting}[xrightmargin=2.5em]
>>> np.empty((2,1))
array([[5.73021895e-300],
       [6.95260453e-310]])
\end{lstlisting}

\end{itemize}
Observamos que o tamanho dos eixos é passado por um {\PYTHONtuple}.

\subsection{Manipulação}

O {\numpy} contém várias funções para a manipulação de \texttt{arrays}. Algumas das mais usadas são:
\begin{itemize}
\item {\PYTHONnumpyDOTreshape} \hl{reformatação de um arranjo}.

\begin{lstlisting}[xrightmargin=2.5em]
>>> a = np.array([[1,2,3],[4,5,6]])
>>> a.reshape(3,2)
array([[1, 2],
       [3, 4],
       [5, 6]])
>>> a.reshape(-1)
array([1, 2, 3, 4, 5, 6])
\end{lstlisting}

\item {\PYTHONnumpyDOTconcatenate} \hl{concatena um {\PYTHONtuple} de arranjos}.

\begin{lstlisting}[xrightmargin=2.5em]
>>> a = np.array([1,2,3])
>>> b = np.array([4,5,6])
>>> np.concatenate((a,b))
array([1, 2, 3, 4, 5, 6])
>>> a = a.reshape(1,-1)
>>> b = b.reshape(1,-1)
>>> np.concatenate((a,b))
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.concatenate((a,b), axis=1)
array([[1, 2, 3, 4, 5, 6]])
\end{lstlisting}

\end{itemize}

\subsection{Operações e Funções Elementares}

De forma análoga a arranjos unidimensionais, as operações aritméticas e funções elementares são aplicadas elemento-a-elementos em um arranjo. Por exemplo,

\begin{lstlisting}
>>> a = np.array([[0.,1/6],[1/4,1/3]])
>>> b = np.array([[0.,6],[4,3]])
>>> np.sin(np.pi*a*b)
array([[0.0000000e+00, 1.2246468e-16],
       [1.2246468e-16, 1.2246468e-16]])
\end{lstlisting}

\subsubsection{Multiplicação Matriz-Vetor}

Dada uma matriz $A = [a_{i,j}]_{i,j=1}^{n,m}$ e um vetor $\pmb{x} = (x_i)_{i=1}^m$, a \hlemph{multiplicação matriz-vetor} $A\pmb{x}$ é definida por
\begin{subequations}
  \begin{align}
    A\pmb{x} &=\begin{bmatrix}
      a_{1,1} & a_{1,2} & \cdots & a_{1,m}\\
      a_{2,1} & a_{2,2} & \cdots & a_{2,m}\\
      \vdots & \vdots & \vdots & \vdots\\
      a_{n,1} & a_{n,2} & \cdots & a_{n,m}
    \end{bmatrix}\begin{bmatrix}
      x_1\\
      x_2\\
      \vdots\\
      x_m
    \end{bmatrix}\\
    &=
      \begin{bmatrix}
        a_{1,1}x_1 + a_{1,2}x_2 + \cdots + a_{1,m}x_m\\
        a_{2,1}x_1 + a_{2,2}x_2 + \cdots + a_{2,m}x_m\\
        \cdots\\
        a_{n,1}x_1 + a_{n,2}x_2 + \cdots + a_{n,m}x_m
      \end{bmatrix}
  \end{align}
\end{subequations}

\begin{ex}
  Considere a matriz
  \begin{equation}
    A =
    \begin{bmatrix}
      1 & -1 & 2\\
      2 & 1 & 3\\
      0 & 2 & 1
    \end{bmatrix}
  \end{equation}
  e o vetor $\pmb{x} = (-1, 2, 1)$. A multiplicação matriz-vetor é
  \begin{subequations}
    \begin{align}
      A\pmb{x} &= \begin{bmatrix}
        1 & -1 & 2\\
        2 & 1 & 3\\
        0 & 2 & 1
      \end{bmatrix}
      \begin{bmatrix}
        -1\\
        2\\
        1
      \end{bmatrix}\\
               &= (-1, 3, 5)
    \end{align}
   \end{subequations}

\begin{lstlisting}
import numpy as np

def MatrizVetor(A, x):
    n,m = A.shape
    y = np.empty(n)
    for i in range(n):
        y[i] = 0.
        for j in range(m):
            y[i] += A[i,j]*x[j]
    return y

A = np.array([[1, -1, 2],
              [2,  1, 3],
              [0,  2, 1]])
x = np.array([-1, 2, 1])
print(MatrizVetor(A,x))
\end{lstlisting}

\end{ex}

\subsubsection{Multiplicação Matriz-Matriz}

Dadas matrizes $A = [a_{i,j}]_{i,j=1}^{n,p}$ e $B = [b_{i,j}]_{i,j=1}^{p,m}$, a \hlemph{multiplicação matriz-matriz} $AB$ é a matriz $AB = C = [c_{i,j}]_{i,j=1}^{n,m}$ de elementos
\begin{equation}
  c_{i,j} = \sum_{k=1}^{p} a_{i,k}\cdot b_{k,j}.
\end{equation}

\begin{ex}
  Consideramos as matrizes
  \begin{equation}
    A =
    \begin{bmatrix}
      1 & -1 & 2\\
      2 & 1 & 3\\
      0 & 2 & 1
    \end{bmatrix}
  \end{equation}
  \begin{equation}
    B =
    \begin{bmatrix}
      2 & 0\\
      1 & 2\\
      0 & 2
    \end{bmatrix}
  \end{equation}
  A multiplicação matriz-matriz $AB$ é
  \begin{subequations}
    \begin{align}
      AB &= \begin{bmatrix}
      1 & -1 & 2\\
      \hleq{2} & \hleq{1} & \hleq{3}\\
      0 & 2 & 1
    \end{bmatrix}\begin{bmatrix}
      2 & \hleq{0}\\
      1 & \hleq{2}\\
      0 & \hleq{2}
    \end{bmatrix}
        &=
          \begin{bmatrix}
            1 & 2\\
            5 & \hleq{8}\\
            2 & 6
          \end{bmatrix}
    \end{align}
  \end{subequations}

\begin{lstlisting}
def MatrizMatriz(A, B):
    n,p = A.shape
    m = B.shape[1]
    C = np.empty((n,m))
    for i in range(n):
        for j in range(m):
            C[i,j] = 0.
            for k in range(p):
                C[i,j] += A[i,k]*B[k,j]
    return C

A = np.array([[1, -1, 2],
              [2,  1, 3],
              [0,  2, 1]])
B = np.array([[2, 0],
              [1, 2],
              [0, 2]])
print(MatrizMatriz(A,B))
\end{lstlisting}

\end{ex}

\subsection{Exercícios}

\begin{exer}
  Aloque o arranjo que corresponde a matriz
  \begin{equation}
    A =
    \begin{bmatrix}
      -2 & 1 & -4\\
      0  & -3 & 2\\
      -1 & 5 & -7\\
      2 & 3 & 6
    \end{bmatrix}
  \end{equation}
  Sem implementar, forneça a saída das seguintes instruções:
  \begin{enumerate}[a)]
  \item \lstinline+A[2,1]+
  \item \lstinline+A[0,2]+
  \item \lstinline+A[-2,-2]+
  \item \lstinline+A[3]+
  \item \lstinline+A[3:,:]+
  \item \lstinline+A[:,2]+
  \item \lstinline+A[:,1:2]+
  \end{enumerate}
\end{exer}
\begin{resp}
  Dica: aloque o arranjo e implemente as instruções.
\end{resp}

\begin{exer}
  Considere o arranjo

\begin{lstlisting}
A = np.array([[[-1,2,0],
               [3,-2,1],
               [1,-4,2]],
              [[2,-1,0],
               [5,-2,0],
               [2,6,3]],
              [[1,-1,0],
               [7,-2,4],
               [2,-2,1]]])
\end{lstlisting}

Sem implementar, forneça a saída das seguintes instruções:
  \begin{enumerate}[a)]
  \item \lstinline+A[2,0,1]+
  \item \lstinline+A[1,1,0]+
  \item \lstinline+A[2]+
  \item \lstinline+A[1,2]+
  \item \lstinline+A[1:,:2,2]+
  \end{enumerate}
\end{exer}
\begin{resp}
  Dica: aloque o arranjo e implemente as instruções.
\end{resp}

\begin{exer}
  Considere o arranjo

\begin{lstlisting}
>>> a = np.array([[1,2],[5,8],[2,6]])
>>> a
array([[1, 2],
       [5, 8],
       [2, 6]])
\end{lstlisting}

Sem implementar, escreva os seguintes arranjos derivados:
  \begin{enumerate}[a)]
  \item \lstinline+a.reshape(6)+
  \item \lstinline+a.reshape(2,3)+
  \item \lstinline+a.reshape(-1)+
  \item \lstinline+a.reshape(-1,3)+
  \item \lstinline+a.reshape(3,-1)+
  \item \lstinline+a.reshape(4,-1)+
  \end{enumerate}
\end{exer}
\begin{resp}
  Dica: aloque o arranjo e implemente as instruções.
\end{resp}

\begin{exer}
  Considere os arranjos

\begin{lstlisting}
>>> a = np.array([1,2,3]).reshape(1,-1)
>>> b = np.array([4,5,6]).reshape(-1,1)
\end{lstlisting}

Sem implementar, escreva os seguintes arranjos derivados:
  \begin{enumerate}[a)]
  \item \lstinline+np.concatenate((a,b.reshape(1,-1)))+
  \item \lstinline+np.concatenate((a.reshape(-1,1),b))+
  \item \lstinline+np.concatenate((a,b.reshape(1,-1)), axis=1)+
  \item \lstinline+np.concatenate((a.reshape(-1,1),b), axis=1)+
  \end{enumerate}
\end{exer}
\begin{resp}
  Dica: aloque o arranjo e implemente as instruções.
\end{resp}

\begin{exer}
  Implemente uma função que recebe uma matriz (representada por um \lstinline+array+) e retorna a sua transposta. Teste seu código para diversas matrizes com diversos formatos.
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np

def Transposta(A):
    n,m = A.shape
    B = np.empty((m,n))
    for i in range(n):
        for j in range(m):
            B[j,i] = A[i,j]
    return B
\end{lstlisting}

\end{resp}

\begin{exer}
  Implemente uma função que compute a multiplicação vetor-matriz
  \begin{subequations}
    \begin{align}
      \pmb{y} &= \pmb{x}A \\
              &:= \begin{bmatrix}
                x_1 & x_2 & \cdots & x_n
              \end{bmatrix}
              \begin{bmatrix}
                a_{1,1} & a_{1,2} & \cdots & a_{1,m}\\
                a_{2,1} & a_{2,2} & \cdots & a_{2,m}\\
                \vdots & \vdots & \vdots & \vdots\\
                a_{n,1} & a_{n,2} & \cdots & a_{n,m}
              \end{bmatrix}
    \end{align}
  \end{subequations}
  onde, por definição, $\pmb{y} = [y_j]_{j=1}^m$, com elementos
  \begin{equation}
    y_j = \sum_{k=1}^n x_k\cdot a_{k,j}.
  \end{equation}
\end{exer}
\begin{resp}
  Dica: a função {\PYTHONnumpyDOTdot} também computa a multiplicação vetor-matriz. Teste sua implementação para diferentes matriz e vetores de diferentes tamanhos.
\end{resp}

\ifisbook
\subsubsection{Respostas}
\shipoutAnswer
\fi


\section{Matrizes}\label{cap_arr_sec_mat}

Arranjos multidimensionais\endnote{Consulte a Seção \ref{cap_arr_sec_multi}} fornecem uma estrutura adequada para a representação de matrizes em computador. \hl{Uma matriz $A$, assim como um arranjo bidimensional, é uma coleção de valores organizados de forma retangular}, por exemplo, a matriz $A = [a_{i,j}]_{i,j=1}^{n,m}$ tem a forma
\begin{equation}\hleq
  A =
  \begin{bmatrix}
    a_{1,1} & a_{1,2} & \cdots & a_{1,m}\\
    a_{2,1} & a_{2,2} & \cdots & a_{2,m}\\
    \vdots & \vdots & \vdots & \vdots\\
    a_{n,1} & a_{n,2} & \cdots & a_{n,m}
  \end{bmatrix}
\end{equation}
Seus elementos $a_{i,j}$ são organizados por eixos, o eixo das linhas (\lstinline+axis=0+) e o eixo das colunas (\lstinline+axis=1+).

\begin{ex}\label{cap_arr_sec_mat:ex:sislin}
  O sistema linear
  \begin{subequations}
    \begin{align}
      &2x_1 - x_2 + x_3 = -3\\
      &-x_1 + x_2 + {\hleq 3}x_3 = {\hleq 6}\\
      &x_1 + 3x_2 - 3x_3 = 2
    \end{align}
  \end{subequations}
  pode ser escrito na seguinte forma matricial
  \begin{equation}
    A\pmb{x} = \pmb{b},
  \end{equation}
  onde $A = [a_{i,j}]_{i,j=1}^{3,3}$ é a matriz de coeficientes
  \begin{equation}
    A =
    \begin{bmatrix}
      2 & -1 & 1\\
      -1 & 1 & {\hleq 3}\\
      1 & 3 & -3
    \end{bmatrix},
  \end{equation}
  o vetor dos termos constantes $\pmb{b} = (b_1, b_2, b_3)$ é
  \begin{equation}
    \pmb{b} = (-3, {\hleq 6}, 2),
  \end{equation}
  enquanto que o vetor das incógnitas é $\pmb{x} = (x_1, x_2, x_3)$. No seguinte código, usamos {\PYTHONnumpyDOTarray} para alocamos a matriz dos coeficientes $A$ e o vetor dos termos constantes $\pmb{b}$.

\begin{lstlisting}
import numpy as np
# matriz dos coefs
A = np.array([[2, -1, 1],
              [-1, 1, 3],
              [1, 3, -3]])
# vet termos consts
b = np.array([-3, 6, 2])
\end{lstlisting}

\end{ex}

\subsection{Operações Matriciais}

Embora úteis para a representação de matrizes, \hl{arranjos bidimensionais não são equivalentes a matrizes}. Em arranjos, as operações aritméticas elementares (\lstinline!+!, \lstinline!-!, \lstinline!*!, \lstinline!/!, etc.) são operações elemento-a-elemento, para matrizes a multiplicação não é assim calculada e a divisão não é definida.

\subsubsection{Multiplicação Matricial}

No {\numpy}, as funções {\PYTHONnumpyDOTdot}, {\PYTHONnumpyDOTmatmul} ou o operador \lstinline+@+ podem ser usados para computar a multiplicação matricial.

\begin{ex}
  Considerando as matrizes
  \begin{equation}
    A =
    \begin{bmatrix}
      2 & -1 & 1\\
      -1 & 1 & {\hleq 3}\\
      1 & 3 & -3
    \end{bmatrix},
  \end{equation}
  \begin{equation}
    B =
    \begin{bmatrix}
      1 & -1\\
      2 & 1\\
      1 & 0
    \end{bmatrix}
  \end{equation}
  temos
  \begin{equation}
    AB =
    \begin{bmatrix}
      1 & -3\\
      4 & 2\\
      4 & 2
    \end{bmatrix}
  \end{equation}
  Usando o {\numpy}, temos

\begin{lstlisting}
import numpy as np

A = np.array([[2, -1, 1],
              [-1, 1, 3],
              [1, 3, -3]])

B = np.array([[1, -1],
              [2, 1],
              [1, 0]])

AB = A@B
print(f'AB =\n {AB}')

AB = np.matmul(A, B)
print(f'AB =\n {AB}')

AB = np.dot(A, B)
print(f'AB =\n {AB}')
\end{lstlisting}

\end{ex}

\begin{ex}
  Consideramos o sistema linear introduzido no Exemplo \ref{cap_arr_sec_mat:ex:sislin}. Vamos verificar que sua solução é $x_1 = -1$, $x_2 = 2$ e $x_3 = 1$. Equivalentemente, temos que
  \begin{equation}
    A\pmb{x} = \pmb{b},
  \end{equation}
  com $\pmb{x} = (-1, 2, 1)$. Isto é, se $\pmb{x}$ é solução do sistema, então é nulo o resíduo $\pmb{b} - A\pmb{x}$, i.e.
  \begin{equation}
    \pmb{b} - A\pmb{x} = \pmb{0}.
  \end{equation}
  Ou equivalentemente, $\|\pmb{b} - A\pmb{x}\| = 0$.

\begin{lstlisting}
import numpy as np
import numpy.linalg as npla

# matriz dos coefs
A = np.array([[2, -1, 1],
              [-1, 1, 3],
              [1, 3, -3]])
# vet termos consts
b = np.array([-3, 6, 2])
# solução
x = np.array([-1, 2, 1])

# verificação
res = b - A@x
norm_res = npla.norm(res)
print(f'É solução? {np.isclose(norm_res, 0.)}')
\end{lstlisting}

\end{ex}

\subsubsection{Matriz Transposta}

Por definição, a transposta de uma matriz $A = [a_{i,j}]_{i,j=1}^{n,m}$ é a matriz $A^T = [a_{j,i}]_{j,i=1}^{m,n}$, i.e. a matriz $B$ obtida de $A$ pela permutação de suas linhas com suas colunas. No {\numpy}, a transposta de um arranjo bidimensional pode ser calculado com a função {\PYTHONnumpyDOTtranspose}, com o método {\PYTHONnumpyDOTndarrayDOTtranspose} ou com o atributo {\PYTHONnumpyDOTndarrayDOTT}.

\begin{ex}
  Uma matriz é dita ser simétrica, quando $A = A^T$. Observamos que é simétrica a matriz
  \begin{equation}
    A =
    \begin{bmatrix}
      2 & -1 & 1\\
      -1 & 1 & {\hleq 3}\\
      1 & 3 & -3
    \end{bmatrix},
  \end{equation}

\begin{lstlisting}
import numpy as np
A = np.array([[2, -1, 1],
              [-1, 1, 3],
              [1, 3, -3]])

trans_A = np.transpose(A) 
print(f'A^T =\n {trans_A}')

trans_A = A.transpose() 
print(f'A^T =\n {trans_A}')

trans_A = A.T
print(f'A^T =\n {trans_A}')

print(f'É simétrica? {np.allclose(A, A.T)}')
\end{lstlisting}

Agora, não é simétrica a matriz
  \begin{equation}
    B =
    \begin{bmatrix}
      1 & -1\\
      2 & 1\\
      1 & 0
    \end{bmatrix}.
  \end{equation}

\begin{lstlisting}
import numpy as np
B = np.array([[1, -1],
              [2, 1],
              [1, 0]])
print(B.T)
\end{lstlisting}

\end{ex}

\subsubsection{Determinante}

Por definição, o determinante de uma matriz $A = [a_{i,j}]_{i,j=1}^{n,n}$ é o escalar
\begin{subequations}
  \begin{align}
    \det(A) &=
              \begin{vmatrix}
                a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\
                a_{2,1} & a_{2,2} & \cdots & a_{2,n}\\
                \vdots & \vdots & \vdots & \vdots\\
                a_{n,1} & a_{n,2} & \cdots & a_{n,n}                
              \end{vmatrix}\\
            &:= \sum_{\sigma\in S_n}\sign(\sigma)a_{1,\sigma_1}a_{2,\sigma_2}\cdots a_{n,\sigma_n}
  \end{align}
\end{subequations}
onde $S_n$ é o conjunto de todas as permutações de ${1, 2, \dotsc, n}$ e $\sign(\sigma)$ é o sinal (ou assinatura) da permutação $\sigma\in S_n$. Para matrizes $2\times 2$, temos
\begin{subequations}
  \begin{align}
    \det(A) &=
        \begin{vmatrix}
          a_{1,1} & a_{1,2}\\
          a_{2,1} & a_{2,2}
        \end{vmatrix}\\
      &= a_{1,1}a_{2,2} - a_{1,2}a_{2,1}.
  \end{align}
\end{subequations}
Enquanto que no caso de matriz $3\times 3$, temos
\begin{subequations}
  \begin{align}
    \det(A) &=
              \begin{vmatrix}
                a_{1,1} & a_{1,2} & a_{1,3}\\
                a_{2,1} & a_{2,2} & a_{2,3}\\
                a_{3,1} & a_{3,2} & a_{3,3}
              \end{vmatrix}\\
            &= a_{1,1}a_{2,2}a_{3,3}\\
            &+ a_{1,2}a_{2,3}a_{3,1}\\
            &+ a_{1,3}a_{2,1}a_{3,2}\\
            &- a_{1,3}a_{2,2}a_{3,1}\\
            &- a_{1,1}a_{2,3}a_{3,2}\\
            &- a_{1,2}a_{2,1}a_{3,3}.
  \end{align}
\end{subequations}

A função {\PYTHONnumpyDOTlinalgDOTdet} do {\numpy} pode ser usado para computar o determinante de um arranjo.

\begin{ex}
  O determinante
  \begin{subequations}
    \begin{align}
      \det(A) &=
                \begin{vmatrix}
                  2 & -1 & 1\\
                  -1 & 1 & {\hleq 3}\\
                  1 & 3 & -3
                \end{vmatrix}\\
              &= -28
    \end{align}
  \end{subequations}

\begin{lstlisting}
import numpy as np
import numpy.linalg as npla
A = np.array([[2, -1, 1],
              [-1, 1, 3],
              [1, 3, -3]])

detA = npla.det(A)
print(f'det(A) = {detA}')
\end{lstlisting}

\end{ex}

\subsection{Aplicação: Método de Cramer}

O \hl{\emph{Método de Cramer}}{\cramer} usa de determinantes para o \hl{cálculo da solução de sistemas lineares}. Dado um sistema linear $n\times n$
\begin{equation}\hleq
  A\pmb{x} = \pmb{b}
\end{equation}
denotamos a matriz dos coeficientes por
\begin{equation}
  A =
  \begin{bmatrix}
    \pmb{a}_1 & \pmb{a}_2 & \cdots & \pmb{a}_n
\end{bmatrix},
\end{equation}
onde $\pmb{a}_i$ denota a $i$-ésima coluna de $A$. Vamos denotar por $A_i$ a matriz obtida de $A$ substituindo $\pmb{a}_i$ pelo vetor dos termos constantes $\pmb{b}$, i.e.
\begin{equation}
  A_i :=
  \begin{bmatrix}
    \pmb{a}_1 & \cdots & \pmb{a}_{i-1} & {\hleq \pmb{b}} & \pmb{a}_{i+1} & \cdots & \pmb{a}_n
  \end{bmatrix}
\end{equation}
\hl{O método consiste em computar a solução $\pmb{x} = (x_1, x_2, \ldots, x_n)$ com}
\begin{equation}\hleq
  x_i = \frac{\det(A_i)}{\det(A)},
\end{equation}
para cada $i = 1, 2, \dotsc, n$.

\begin{ex}
  Vamos resolver o sistema linear dado no Exercício \ref{cap_arr_sec_mat:ex:sislin}. Sua forma matricial é
  \begin{equation}
    A\pmb{x} = \pmb{b}
  \end{equation}
  com matriz dos coeficientes
  \begin{equation}
        A =
    \begin{bmatrix}
      2 & -1 & 1\\
      -1 & 1 & 3\\
      1 & 3 & -3
    \end{bmatrix},
  \end{equation}
  e vetor dos termos constantes
  \begin{equation}
    \pmb{b} = ({\hleq -3, ~6, ~2}).
  \end{equation}
  Para aplicação do Método de Cramer, calculamos
  \begin{subequations}
    \begin{align}
      \det(A) &:=
                \begin{vmatrix}
                  2 & -1 & 1\\
                  -1 & 1 & 3\\
                  1 & 3 & -3
                \end{vmatrix}\\
              &= -28
    \end{align}
  \end{subequations}    
  e das matrizes auxiliares
  \begin{subequations}
    \begin{align}
      \det(A_1) &:=
                \begin{vmatrix}
                  {\hleq -3} & -1 & 1\\
                  {\hleq 6} & 1 & 3\\
                  {\hleq 2} & 3 & -3
                \end{vmatrix}\\
              &= 28
    \end{align}
  \end{subequations}
  \begin{subequations}
    \begin{align}
      \det(A_2) &:=
                \begin{vmatrix}
                  2 & {\hleq -3} & 1\\
                  -1 & {\hleq 6} & 3\\
                  1 & {\hleq 2} & -3
                \end{vmatrix}\\
              &= -56
    \end{align}
  \end{subequations}
  \begin{subequations}
    \begin{align}
      \det(A_3) &:=
                \begin{vmatrix}
                  2 & -1 & {\hleq -3}\\
                  -1 & 1 & {\hleq 6}\\
                  1 & 3 & {\hleq 2}
                \end{vmatrix}\\
              &= -28
    \end{align}
  \end{subequations}
  Com isso, obtemos a solução
  \begin{subequations}
    \begin{align}
      x_1 &= \frac{\det(A_1)}{\det(A)} = -1,\\
      x_2 &= \frac{\det(A_2)}{\det(A)} = 2,\\
      x_3 &= \frac{\det(A_3)}{\det(A)} = 1.
    \end{align}
  \end{subequations}

\begin{lstlisting}
import numpy as np
import numpy.linalg as npla
# matriz dos coefs
A = np.array([[2, -1, 1],
              [-1, 1, 3],
              [1, 3, -3]])
# vet termos consts
b = np.array([-3, 6, 2])

# det(A)
detA = npla.det(A)
print(f'det(A) = {detA}')

# matrizes auxiliares
## A1
A1 = np.copy(A)
A1[:,0] = b
detA1 = npla.det(A1)
print(f'det(A1) = {detA1}')

## A2
A2 = np.copy(A)
A2[:,1] = b
detA2 = npla.det(A2)
print(f'det(A2) = {detA2}')

## A3
A3 = np.copy(A)
A3[:,2] = b
detA3 = npla.det(A3)
print(f'det(A3) = {detA3}')

# solucao
x = np.array([detA1/detA, detA2/detA, detA3/detA])
print(f'x = {x}')
\end{lstlisting}

\end{ex}


\subsection{Exercícios}

\begin{exer}
  Aloque com {\PYTHONnumpyDOTarray} e imprima as seguintes matrizes:
  \begin{enumerate}[a)]
  \item
    \begin{equation}
      A =
      \begin{bmatrix}
        -1 & 2\\
        7 & -3
      \end{bmatrix}
    \end{equation}
  \item
    \begin{equation}
      B =
      \begin{bmatrix}
        -1 & 2 & 4\\
        7 & -3 & -5 
      \end{bmatrix}
    \end{equation}
  \item
    \begin{equation}
      C =
      \begin{bmatrix}
        -1 & 2 & 4\\
        7 & -3 & -5\\
        2 & 9 & 6
      \end{bmatrix}
    \end{equation}
  \item
    \begin{equation}
      D =
      \begin{bmatrix}
        -1 & 2 & 4\\
        7 & -3 & -5\\
        2 & 9 & 6\\
        1 & -1 & 1
      \end{bmatrix}
    \end{equation}
  \end{enumerate}
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np
# a)
A = np.array([[-1, 2],
              [7, -3]])
print(f'A =\n {A}')
# b)
B = np.array([[-1, 2, 4],
              [7, -3, -5]])
print(f'B =\n {B}')
# c)
C = np.array([[-1, 2, 4],
              [7, -3, -5],
              [2, 9, 6]])
print(f'C =\n {C}')
# d)
D = np.array([[-1, 2, 4],
              [7, -3, -5],
              [2, 9, 6],
              [1, -1, 1]])
print(f'D =\n {D}')
\end{lstlisting}

\end{resp}

\begin{exer}
  Aloque as seguintes matrizes com {\PYTHONnumpyDOTarray}
  \begin{equation}
    A =
    \begin{bmatrix}
        -1 & 2 & 4\\
        7 & -3 & -5
      \end{bmatrix}      
  \end{equation}
  e
  \begin{equation}
    B =
    \begin{bmatrix}
        1 & -1 & 2\\
        3 & 0 & 5
      \end{bmatrix}.      
  \end{equation}
  Então, compute e imprima o resultado das seguintes operações matriciais
  \begin{enumerate}[a)]
  \item $A + B$
  \item $A - B$
  \item $2A$
  \end{enumerate}
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np
A = np.array([[-1, 2, 4],
              [7, -3, -5]])
B = np.array([[1, -1, 2],
              [3, 0, 5]])
# a)
ApB = A + B
print(f'A+B =\n {ApB}')
# b)
AmB = A - B
print(f'A-B =\n {AmB}')
# c)
_2A = 2*A
print(f'2A =\n {_2A}')
\end{lstlisting}

\end{resp}

\begin{exer}
  Aloque as seguintes matrizes {\PYTHONnumpyDOTarray}:
  \begin{equation}
    A =
    \begin{bmatrix}
        -1 & 2 & 4\\
        7 & -3 & -5
      \end{bmatrix}      
  \end{equation}
  e
  \begin{equation}
    B =
    \begin{bmatrix}
        1 & -1\\
        3 & 0\\
        2 & 5
      \end{bmatrix}.      
  \end{equation}
  Então, compute e imprima o resultado das seguintes operações matriciais:
  \begin{enumerate}[a)]
  \item $AB$
  \item $BA$
  \item $B^T$
  \item $A^TB^T$
  \end{enumerate}
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np
A = np.array([[-1, 2, 4],
              [7, -3, -5]])
B = np.array([[1, -1],
              [3, 0],
              [2, 5]])
# a)
AB = A @ B
print(f'AB =\n {AB}')
# b)
BA = B @ A
print(f'BA =\n {BA}')
# c)
Bt = B.T
print(f'B^T =\n {Bt}')
# d)
AtBt = A.T @ B.T
print(f'A^T.B^T =\n {AtBt}')
\end{lstlisting}

\end{resp}

\begin{exer}\label{cap_arr_sec_mat:exer:sislin}
  Escreva a forma matricial $A\pmb{x} = \pmb{b}$ do seguinte sistema linear
  \begin{subequations}
    \begin{align}
      &-x_1 + 2x_2 - 2x_3 = 6\\
      &3x_1 - 4x_2 + x_3 = -11\\
      &x_1 -5x_2 + 3x_3 = -10
    \end{align}
  \end{subequations}
  Use {\PYTHONnumpyDOTarray} para alocar a matriz dos coeficientes $A$ e o vetor dos termos constantes $\pmb{b}$. Então, verifique quais dos seguintes vetores é solução do sistema
  \begin{enumerate}[a)]
  \item $\pmb{x} = (1, -1, -2)$
  \item $\pmb{x} = (-1, -2, 1)$
  \item $\pmb{x} = (-2, 1, -1)$
  \end{enumerate}
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np
A = np.array([[-1, 2, -2],
              [3, -4, 1],
              [1, -5, 3]])
b = np.array([6, -11, -10])
# c)
x = np.array([-2, 1, -1])
print(f'É solução? {np.allclose(A@x, b)}')
\end{lstlisting}

\end{resp}

\begin{exer}
  Calcule e compute o determinante das seguintes matrizes
  \begin{enumerate}[a)]
  \item
    \begin{equation}
      A =
      \begin{bmatrix}
        -1 & 2\\
        7 & -3
      \end{bmatrix}
    \end{equation}
  \item
    \begin{equation}
      B =
      \begin{bmatrix}
        -1 & 2 & 4\\
        1 & -3 & -5\\
        2 & 0 & 6
      \end{bmatrix}
    \end{equation}
  \item
    \begin{equation}
      C =
      \begin{bmatrix}
        -1 & 2 & 4 & 1\\
        7 & -3 & -5 & -1\\
        2 & 0 & 1 & 0\\
        1 & -1 & 1 & -2
      \end{bmatrix}
    \end{equation}
  \end{enumerate}
\end{exer}
\begin{resp}

\begin{lstlisting}
import numpy as np
import numpy.linalg as npla
# a)
A = np.array([[-1, 2],
              [7, -3]])
detA = npla.det(A)
print(f'det(A) =\n {detA}')
# b)
B = np.array([[-1, 2, 4],
              [1, -3, -5],
              [2, 0, 6]])
detB = npla.det(B)
print(f'det(B) =\n {detB}')
# c)
C = np.array([[-1, 2, 4, 1],
              [-1, -3, -5, -1],
              [2, 0, 1, 0],
              [1, -1, 1, -2]])
detC = npla.det(C)
print(f'det(C) =\n {detC}')
\end{lstlisting}

\end{resp}

\begin{exer}
  Use o Método de Cramer para computar a solução do sistema dado no Exercício \ref{cap_arr_sec_mat:exer:sislin}. Verifique sua solução com a computada pelo método {\PYTHONnumpyDOTlinalgDOTsolve}.
\end{exer}
\begin{resp}
  Dica: $\pmb{x} = (-2, 1, -1)$.
\end{resp}

\begin{exer}
  Desenvolva sua própria função {\python} para a computação do determinante de uma matriz $A$ $n\times n$.
\end{exer}
\begin{resp}
  Dica: use a função {\PYTHONintertoolsDOTpermutations} para obter um iterador sobre as permutações.
\end{resp}

\ifisbook
\subsubsection{Respostas}
\shipoutAnswer
\fi
