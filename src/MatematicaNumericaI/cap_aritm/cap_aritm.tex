\chapter{Aritmética de Máquina}\label{cap_aritm}

\begin{lstlisting}
0.1 + 0.2 == 0.3
\end{lstlisting}

\begin{verbatim}
False
\end{verbatim}

\section{Sistema de Numeração Posicional}\label{cap_aritm_sec_sisnumpos}

Cotidianamente, usamos o sistema de numeração posicional na base decimal. Por exemplo, temos
\begin{equation}
  123.5 = 1\times 10^2 + 2\times 10^1 + 3\times 10^0 + 5\times 10^{-1},
\end{equation}
onde o algarismo/dígito 1 está na posição 2 (posição das centenas), o dígito 2 está na posição 1 (posição das dezenas) e o dígito 3 está na posição 0 (posição das unidades). Mais geralmente, temos a representação decimal
\begin{gather}
  \pm d_n\ldots d_2d_1d_0,d_{-1}d_{-2}d_{-3}\ldots \\
  := \pm \left(d_n\times 10^n + \cdots + d_2\times 10^2 + d_1\times 10^1 + d_0\times 10^0\right. \\
      \left. + d_{-1}\times 10^{-1} + d_{-2}\times 10^{-2} + d_{-3}\times 10^{-3} + \cdots\right),
\end{gather}
cujos os dígitos $d_i \in \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$, $i=n, \dotsc, 2, 1, 0, -1, -2, -3, \ldots$. Observamos que esta representação posicional pode ser generalizada para outras bases numéricas.

\begin{defn}\normalfont{(Representação posicional)}\label{defn:representacao_posicional}
  Dada uma base ${\color{blue}b}\in\mathbb{N}\setminus \{0\}$, definimos a representação
  \begin{gather}
    \pm (d_n\ldots d_2d_1d_0,d_{-1}d_{-2}d_{-3}\ldots)_{\color{blue}b} \\
    := \pm \left(d_n\times b^n + \cdots + d_2\times b^2 + d_1\times b^1 + d_0\times b^0\right. \\
      \left. + d_{-1}\times b^{-1} + d_{-2}\times b^{-2} + d_{-3}\times b^{-3} + \cdots\right),
  \end{gather}
onde os dígitos $d_i\in\{0, 1, \dotsc, {\color{blue}b}-1\}$\endnote{Para bases $b\geq 11$, usamos a representação dos dígitos maiores ou iguais a 10 por letras maiúsculas do alfabeto latino, i.e. $A=10$, $B=11$, $C=12$ e assim por diante.}, $i=n, \dotsc, 2, 1, 0, -1, -2, -3, \ldots$.
\end{defn}

\begin{ex}\normalfont{(Representação binária)}\label{ex:base_binaria}
  O número $(11010.101)_2$ está escrito na representação binária (base $b=2$). Da Definição~\ref{defn:representacao_posicional}, temos
  \begin{gather}
    (\stackrel{4}{1}~\stackrel{3}{1}~\stackrel{2}{0}~\stackrel{1}{1}~\stackrel{0}{0}.\stackrel{-1}{~\,1}~\stackrel{-2}{~\,0}~\stackrel{-3}{~\,1})_2\\
    = 1\times 2^4 + 1\times 2^3 + 0\times 2^2 + 1\times 2^1 + 0\times 2^0\\
    + 1\times 2^{-1} + 0\times 2^{-2} + 1\times 2^{-3}\\
    = 26.625.
  \end{gather}

\begin{lstlisting}
1*2**4 + 1*2**3 + 0*2**2 + 1*2**1 + 0*2**0 +
1*2**-1 + 0*2**-2 + 1*2**-3
\end{lstlisting}

\begin{verbatim}
  26.625
\end{verbatim}
\end{ex}

\subsection{Mudança de Base}

Um mesmo número pode ser representado em diferentes bases. A mudança de base da representação de um dado número pode ser feita de várias formas. De forma geral, se temos um número $x$ representado na base $b_1$ e queremos obter sua representação na base $b_2$, fazemos
\begin{enumerate}
\item Calculamos a representação do número $x$ na base decimal.
\item Da calculada representação decimal, calculamos a representação de $x$ na base $b_2$.
\end{enumerate}
Observamos que o passo 1. ($b \to 10$) segue imediatamente da Definição \ref{defn:representacao_posicional}. Agora, o passo 2. ($10\to b$), podemos usar o seguinte procedimento. Suponhamos que $x$ tenha a seguinte representação decimal
\begin{equation}
  d_nd_{n-1}d_{n-2}\ldots d_0,d_{-1}d_{-2}d_{-3}\ldots
\end{equation}
Então, separamos sua parte inteira $I = d_nd_{n-1}d_{n-2}\ldots d_0$ e sua parte fracionária $F = 0,d_{-1}d_{-2}d_{-3}\ldots$ ($x = I + F$). Então, usando de sucessivas divisões de $I$ pela base $b$ desejada, obtemos sua representação nesta mesma base. Analogamente, usando de sucessivas multiplicações de $F$ pela base $b$, obtemos sua representação nesta base. Por fim, basta somar as representações calculadas.

\begin{ex}
  Obtenha a representação em base quartenária ($b=4$) do número $(11010.101)_2$.
  \begin{enumerate}[1.]
  \item $b=2 \to 10$. 
    A representação de $(11010.101)_2$ segue direto da Definição \ref{defn:representacao_posicional} (veja, o Exemplo~\ref{ex:base_binaria}). Ou seja, temos
    \begin{gather}
      (\stackrel{4}{1}~\stackrel{3}{1}~\stackrel{2}{0}~\stackrel{1}{1}~\stackrel{0}{0}.\stackrel{-1}{~\,1}~\stackrel{-2}{~\,0}~\stackrel{-3}{~\,1})_2 \\
      = 2^4 + 2^3 + 2^1 + 2^{-1} + 2^{-3} \\
      = 26.625.
    \end{gather}

\begin{lstlisting}
2**4 + 2**3 + 2 + 2**-1 + 2**-3
\end{lstlisting}

\begin{verbatim}
26.625
\end{verbatim}

  \item $b=10 \to 4$.
    Primeiramente, decompomos $26.625$ em sua parte inteira $I = 26$ e em sua parte fracionária $0.625$. Então, ao fazermos sucessivas divisões de $I$ por $b=4$, obtemos:
    \begin{align}
      I &= 26\\
        &= 6\times 4 + 2\times 4^0\\
        &= (1\times 4 + 2)\times 4 + 2\times 4^0\\
        &= 1\times 4^2 + 2\times 4 + 2\times 4^0\\
        &= (122)_4.
    \end{align}

\begin{lstlisting}
I = int(26.625)
d_int = []
while (I != 0):
  d_int.insert(0, I % 4)
  I //= 4
print('(',*d_int,')_4',sep="")
\end{lstlisting}
    
    Agora, para a parte fracionária, usamos sucessivas multiplicações de $F$ por $b=4$, obtendo:
    \begin{align}
      F &= 0.625\\
        &= 2.5\times 4^{-1} = 2\times 4^{-1} + 0.5\times 4^{-1}\\
        &= 2\times 4^{-1} + 2\times 4^{-1}\times 4^{-1}\\
        &= 2\times 4^{-1} + 2\times 4^{-2}\\
        &= (0.22)_{4}.
    \end{align}

\begin{lstlisting}
F = 26.625 % 1
d_fra = []
while (F != 0):
  F *= 4
  d_fra.append(int(F))
  F %= 1
print('(0,',*d_fra,')_4',sep="")
\end{lstlisting}
  \end{enumerate}

  Por fim, dos passos 1. e 2., temos $(11010.101)_2 = (122.22)_4$.

\begin{lstlisting}
print('(',*d_int,',',*d_fra,')_4', sep='')
\end{lstlisting}

\begin{verbatim}
(122.22)_4
\end{verbatim}
\end{ex}

\subsection{Exercícios Resolvidos}

\begin{exeresol}
  Forneça a representação decimal dos seguintes números:
  \begin{enumerate}[a)]
  \item $(10101)_2$
  \item $(0.4321)_5$
  \item $(23.5)_8$
  \item $(A2A)_{11}$
  \item $(BEBE)_{16}$
  \end{enumerate}
\end{exeresol}
\begin{resol}
  \begin{enumerate}[a)]
  \item $(\stackrel{4}{1}~\stackrel{3}{0}~\stackrel{2}{1}~\stackrel{1}{0}\stackrel{0}{1})_2$

\begin{lstlisting}
0b10101
\end{lstlisting}

\begin{verbatim}
21
\end{verbatim}

  \item $(\stackrel{0}{0},\stackrel{-1}{~\,4}~\stackrel{-2}{~\,3}~\stackrel{-3}{~\,2}~\stackrel{-4}{~\,1})_5$

\begin{lstlisting}
4*5**-1+3*5**-2+2*5**-3+5**-4
\end{lstlisting}

\begin{verbatim}
0.9376000000000001
\end{verbatim}
  
  \item $(\stackrel{1}{2}~\stackrel{0}{3},\stackrel{-1}{~\,5})_8$

\begin{lstlisting}
0o235 / 8**1
\end{lstlisting}

\begin{verbatim}
19.625
\end{verbatim}

  \item $(\stackrel{2}{A}~\stackrel{1}{2}~\stackrel{0}{A})_{11}$

\begin{lstlisting}
int('A2A', 11)
\end{lstlisting}

\begin{verbatim}
1242
\end{verbatim}

  \item $(\stackrel{3}{B}~\stackrel{2}{E}~\stackrel{1}{B}~\stackrel{0}{E})_{16}$

\begin{lstlisting}
0xBEBE
\end{lstlisting}

\begin{verbatim}
48830
\end{verbatim}

  \end{enumerate}
\end{resol}

\begin{exeresol}
  Forneça a representação na base indicada dos seguintes números decimais:
  \begin{enumerate}[a)]
  \item $203 \to$ base 2
  \item $0.671875 \to$ base 2
  \item $17.25 \to$ base 8
  \item $3245.875 \to$ base 16
  \end{enumerate}
\end{exeresol}
\begin{resol}
  \begin{enumerate}[a)]

  \item $203 \to$ base 2
    Usando o método {\python} \texttt{bin}, obtemos

\begin{lstlisting}
bin(203)
\end{lstlisting}

\begin{verbatim}
'0b11001011'
\end{verbatim}
    ou seja, $203 = (11001011)_2$.

  \item $0.671875 \to$ base 2.

    Executando o código

\begin{lstlisting}
F = 0.671875
digs = []
while (F != 0):
  F *= 2
  digs.append(int(F))
  F %= 1
print('(0,',*digs,')_2',sep="")      
\end{lstlisting}

\noindent obtemos que $0.671875 = (0.101011)_2$.

  \item $17.25 \to$ base 8

    Temos que
    \begin{align}
      17.25 &= 17 + 0.25\\
            &= 16 + 1 + \frac{2}{8}\\
            &= 2\cdot 8^1 + 1\cdot 8^0 + 2\cdot 8^{-1}\\
            &= (21.2)_8
    \end{align}

  \item $3245.875 \to$ base 16

    Executando o seguinte código

\begin{lstlisting}
# base
b = 16
# dígitos
digs = "0123456789ABCDEF"

# número
x = 3245.875

# parte inteira 
I = int(x)
di = []
while (I != 0):
  di.insert(0, I % b)
  I //= b

# parte fracionária
F = x % 1
df = []
while (F != 0):
  F *= b
  df.append(int(F))
  F %= 1

print('(',*[digs[d] for d in di],\
      ',',*[digs[d] for d in df],f')_{b}',sep="")      
\end{lstlisting}

\noindent obtemos $3245.875 = (CAD,E)_{16}$.      

  \end{enumerate}
\end{resol}

\begin{exeresol}
  Na base indicada, forneça a representação dos seguintes números:
  \begin{enumerate}[a)]
  \item $(1101)_2 \to$ base 8
  \item $(1011.0101)_2 \to$ base 8
  \end{enumerate}
\end{exeresol}
\begin{resol}
  \begin{enumerate}[a)]
  \item $(1101)_2 \to$ base 8

\begin{lstlisting}
oct(0b1101)
\end{lstlisting}

\begin{verbatim}
'0o15'
\end{verbatim}
    
Ou seja, $(1101)_2 = (15)_8$.
    
  \item $(1011.0101)_2 \to$ base 8

    Primeiro, convertemos $(1011.0101)_2$ para decimal (base 10).

\begin{lstlisting}
0b10110101 / 2**4
\end{lstlisting}

\begin{verbatim}
11.3125
\end{verbatim}
    
    Logo, convertemos para a base octal (base 8) com o seguinte código:

\begin{lstlisting}
# base
b = 8

# número
x = 11.3125

# parte inteira 
I = int(x)
di = []
while (I != 0):
  di.insert(0, I % b)
  I //= b

# parte fracionária
F = x % 1
df = []
while (F != 0):
  F *= b
  df.append(int(F))
  F %= 1

print('(',*di,',',*df,f')_{b}',sep="")      
\end{lstlisting}

Com este último, obtemos $(1011.0101)_2 = 11.3125 = (13.24)_8$
  \end{enumerate}  
\end{resol}

\subsection{Exercícios}

\begin{exer}
  Obtenha a representação decimal dos seguinte números:
  \begin{enumerate}[a)]
  \item $(101101.00101)_2$
  \item $(23.1)_4$
  \item $(DAAD)_{16}$
  \item $(33.11)_8$
  \item $(51)_6$
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~$45.15625$; b)~$11.25$; c)~$55981$; d)~$27.140625$; e)~$31$
\end{resp}

\begin{exer}
  Obtenha a representação dos seguintes números decimais na base indicada:
  \begin{enumerate}[a)]
  \item $10$ na base 2.
  \item $45.5$ na base 2.
  \item $41$ na base octal.
  \item $66.31640625$ na base hexadecimal.
  \item $0,\overline{3}$ na base 3.
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~$(1010)_2$; b)~$(101101.1)_2$; c)~$(51)_8$; d) $(42.51)_{16}$; e) $(0.1)_3$
\end{resp}

\begin{exer}
  Obtenha a representação dos seguintes números na base indicada:
  \begin{enumerate}[a)]
  \item $(101101.00101)_2$ na base 4.
  \item $(23.1)_4$ na base 2.
  \item $(2001)_{16}$ na base 8.
  \end{enumerate}
\end{exer}
\begin{resp}
   a)~$(231.022)_4$; b)~$(1011.01)_2$; c)~$(20001)_8$
\end{resp}

\begin{exer}
  Obtenha a representação dos seguintes números na base indicada:
  \begin{enumerate}[a)]
  \item $(0.1)_3$ na base decimal.
  \item $(0,\overline{1})_3$ na base decimal.
  \item $0,\overline{3}$ na base octal.
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~$0,\overline{3}$; b)~$1.5$; c)~$(0,\overline{25})_8$;
\end{resp}

\begin{exer}
  Obtenha a representação dos seguintes números na base indicada:
  \begin{enumerate}[a)]
  \item $0.3$ na base 4.
  \item $0.3$ na base 9.
  \item $(A8)_{16}$ na base 5.
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~$(0.1\overline{03})_4$; b)~$(0,\overline{27})$; c)~$(2.2)_5$
\end{resp}

\ifisbook
\subsubsection{Respostas}
\shipoutAnswer
\fi

%%% SECTION %%%

\section{Representação de Números em Máquina}\label{cap_artm_sec_repummaq}

Usualmente, números são manipulados em máquina através de suas representações em registros com $n$-{\it bits}. Ao longo desta seção, vamos usar a seguinte notação
\begin{equation}
  [b_1 ~ b_2 ~ b_3 ~ \cdots ~ b_n],
\end{equation}
para representar um registro de $n$-{\it bits} $b_i\in\{0, 1\}$, $i=1, 2, \dotsc, n$.

Na sequência, fazemos uma breve discussão sobre as formas comumente usadas para a manipulação de números em computadores.

\subsection{Números Inteiros}

O sistema de complemento de 2 é utilizado em computadores para a manipulação de números inteiros. Nesta representação, um registro de $n$~{\it bits}
\begin{equation}
  [d_1 ~ d_2 ~ d_3 ~ \cdots ~ d_n],
\end{equation}
representa o número inteiro
\begin{equation}
  x = (d_{n-1}~\ldots~d_2~d_1)_2 - d_n2^{n-1}.
\end{equation}

\begin{ex}
  O registro de 8~{\it bits}\endnote{8~{\it bits} = 1~{\it byte} [B].}
  \begin{equation}
    [1 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0]
  \end{equation}
  representa o número
  \begin{align}
    x &= -d_8\cdot 2^{8-1} + (d_7~d_6~\ldots~d_1)_2\\
      &= -0\cdots 2^{7} + (\stackrel{6}{0}~\stackrel{5}{0}~\stackrel{4}{0}~\stackrel{3}{0}~\stackrel{2}{0}~\stackrel{1}{1}~\stackrel{0}{1})_2\\
      &= 2^1 + 2^0 = 3.
  \end{align}
  
  Podemos implementar um conversor de registro para número inteiro como segue

\begin{lstlisting}[caption=packbits8.py, label=cod:packbits8]
def packBitsInt8(dd):
  x = -dd[7] * 2**7
  for i, d in enumerate(dd[:7]):
      x += d * 2**(i)
  return x
\end{lstlisting}

Esta função, converte uma lista de {\it bits} (registro) no inteiro corresponde ao sistema de complemento 2.

\begin{lstlisting}
packBitsInt8([1,1,0,0,0,0,0,0])
\end{lstlisting}

\begin{verbatim}
3
\end{verbatim}
\end{ex}

Na representação de complemento de 2 com $n$~{\it bits}, o menor e o maior números inteiros são obtidos com os registros
\begin{gather}
  -2^{n-1} \sim [0 ~ 0 ~ 0 ~ 0 ~ \cdots ~ 1],\\
  2^{n-1}-1 \sim [1 ~ 1 ~ 1 ~ \cdots ~ 1 ~ 0],
\end{gather}
respectivamente. Já o zero é obtido com o registro
\begin{equation}
  0 \sim [0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0].
\end{equation}

\begin{ex}
  Com um registro de $8$-{\it bits}, temos que o menor e o maior números inteiros que podem ser representados são
  \begin{gather}
    [0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 1] \\
    \sim -2^{7} + (0000000)_2 = -128,
  \end{gather}
  e
  \begin{gather}
    [1 ~ 1 ~ 1 ~ 1 ~ 1 ~ 1 ~ 1 ~ 0] \\
    \sim -0\cdot 2^7 + (1111111)_2 = 127,
  \end{gather}
  respectivamente.

  Usando o Código \ref{cod:packbits8}, temos

\begin{lstlisting}
packBitsInt8([0,0,0,0,0,0,0,1])
\end{lstlisting}

\begin{verbatim}
-128
\end{verbatim}

\begin{lstlisting}
packBitsInt8([1,1,1,1,1,1,1,0])
\end{lstlisting}

\begin{verbatim}
127
\end{verbatim}

\begin{lstlisting}
packBitsInt8([0,0,0,0,0,0,0,0])
\end{lstlisting}

\begin{verbatim}
0
\end{verbatim}
\end{ex}

\begin{obs}
  No {\numpy}, o \texttt{dtype=numpy.int8} corresponde a inteiros de 8~{\it bits}.

\begin{lstlisting}
import numpy as np
np.array([-127, 0, 3, 128, 129], dtype=np.int8)
\end{lstlisting}

\begin{verbatim}
array([-127,    0,    3, -128, -127], dtype=int8)
\end{verbatim}

Consulte a lista de tipos básicos do {\numpy} em \href{https://numpy.org/doc/stable/user/basics.types.html}{NumPy:Data types}.
\end{obs}

A adição de números inteiros na representação de complemento de 2 pode ser feita de maneira simples. Por exemplo, consideremos a soma $3 + 9$ usando registros de 8 {\it bits}. Temos
\begin{align}
  3 &\sim [1 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0]\\
  9 &\sim [1 ~ 0 ~ 0 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0] ~ + \\
  - & -------- \\
 12 &\sim [0 ~ 0 ~ 1 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0]
\end{align}

No sistema de complemento de 2, a representação de um número negativo $-x$ pode ser obtida da representação de $x$, invertendo seus {\it bits} e somando 1. Por exemplo, a representação de $-3$ pode ser obtida da representação de $3$, como segue
\begin{equation}
  3 \sim [1 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0].
\end{equation}
Invertendo seus {\it bits} e somando 1, obtemos
\begin{equation}
  -3 \sim [1 ~ 0 ~ 1 ~ 1 ~ 1 ~ 1 ~ 1 ~ 1].
\end{equation}

A subtração de números inteiros usando a representação de complemento de 2 fica, então, tanto simples quanto a adição. Por exemplo:
\begin{align}
  3 &\sim [1 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0]\\
 -9 &\sim [1 ~ 1 ~ 1 ~ 0 ~ 1 ~ 1 ~ 1 ~ 1] ~ + \\
  - & -------- \\
 -6 &\sim [0 ~ 1 ~ 0 ~ 1 ~ 1 ~ 1 ~ 1 ~ 1]
\end{align}

\subsection{Ponto Flutuante}

A manipulação de números decimais em computadores é comumente realizada usando a representação de ponto flutuante de 64~{\it bits}\endnote{Padrão IEEE 754.}. Nesta, um dado registro de 64~{\it bits}
\begin{equation}
  [s ~ | ~ c_{10} ~ c_9 ~ \ldots ~ c_{0} ~ | ~ m_1 ~ m_2 ~ \ldots ~ m_{52}]
\end{equation}
representa o número
\begin{equation}
  x = (-1)^s M\cdot 2^{c - 1023},
\end{equation}
onde $M$ é chamada de mantissa e $c$ da característica, as quais são definidas por
\begin{align}
  M &:= (1,m_1m_2m_3\ldots m_{52})_2,\\
  c &:= (c_{10}\ldots c_2c_1c_0)_2.
\end{align}

\begin{ex}
  Por exemplo, na representação em ponto flutuante de 64~{\it bits}, temos que o registro
  \begin{equation}\label{eq:regfloat64}
    [1 ~ | ~ 1 ~ 0 ~ \ldots ~ 0 ~ 0 ~ | ~ 1 ~ 0 ~ 1 ~ 0 ~ 0 ~ \ldots ~ 0]
  \end{equation}
  representa o número $-3.25$.

  A seguinte função faz a conversão  uma lista de 64~{\it bits} no número decimal corresponde ao sistema de ponto flutuante de 64~{\it bits}.

\begin{lstlisting}[caption=packBitsDouble.py, label=cod:packBitsDouble]
def packBitsDouble(ld):
  s = ld[0]
  c = 0
  for i, d in enumerate(ld[1:12]):
      c += d * 2**(10-i)
  m = 1.
  for i, d in enumerate(ld[12:]):
      m += d * 2**(-(i+1))
  x = m * 2**(c - 1023)
  return -x if s else x
\end{lstlisting}

Por exemplo, usando-a para o registro acima, obtemos

\begin{lstlisting}
ld = [0]*14
ld[0]=1 
ld[1]=1 
ld[12]=1
ld[13]=1
packBitsDouble(ld)
\end{lstlisting}

\begin{verbatim}
-3.5
\end{verbatim}
\end{ex}

\subsection{Erro de Arredondamento}

Dado um número real $x$, sua representação $fl(x)$ em ponto flutuante é o registro que representa o número mais próximo de $x$. Este procedimento é chamado de arredondamento por proximidade.

A seguinte função obtém a representação em ponto flutuante de 64~{\it bits} de um dado número $x$\endnote{Esta função não é precisa e pode fornecer registros errados devido a erros de arredondamento. Uma alternativa melhor é apresentada na Observação \ref{obs:unpackBitsDouble}.}.

\begin{lstlisting}[caption=unpackBitsDouble.py, label=cod:unpackBitsDouble]
import numpy as np

def unpackBitsDouble(x):
  ld = 64*[0]
  if ( x == 0):
      return ld
  elif (x < 0):
      ld [0] = 1
  x = np.fabs(x)
  c = int(np.log2(x) + 1023)
  m = x/2**(c - 1023)
  for i in range(11):
      ld [11 - i] = c % 2
      c //= 2
  m -= 1
  for i in range(52):
      m *= 2
      ld [12+ i] = int(m)
      m %= 1
  return ld
\end{lstlisting}

Por exemplo, $x = 1.1$ é representado pelo registro

\begin{lstlisting}
ld = unpackBitsDouble(1.1)
ld
\end{lstlisting}

\begin{verbatim}
[0, 0, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 0, 0, 0, 1,
1, 0, 0, 1, 1, 0, 0, 1,
1, 0, 0, 1, 1, 0, 0, 1,
1, 0, 0, 1, 1, 0, 0, 1,
1, 0, 0, 1, 1, 0, 0, 1,
1, 0, 0, 1, 1, 0, 0, 1,
1, 0, 0, 1, 1, 0, 1, 0]
\end{verbatim}

que corresponde ao número

\begin{lstlisting}
flx = packBitsDouble(ld)
print(f'{flx:1.51f}')
\end{lstlisting}

\begin{verbatim}
1.10000000000000008881784197
0012523233890533447265625  
\end{verbatim}

O erro de arredondamento é $|x - fl(x)| \approx 8.9\times 10^{-17}$.

\begin{obs}\label{obs:unpackBitsDouble}
  O seguinte código é uma solução mais pythonica para obter-se o registro em ponto flutuante de 64~{\it bits} de $x = 1.1$.

\begin{lstlisting}
''.join(f'{c:08b}' for c in struct.pack('!d', 1.1))
\end{lstlisting}

\begin{verbatim}
'0011111111110001
1001100110011001
1001100110011001
1001100110011010'  
\end{verbatim}

  Recomendamos consultar \cite{Lemire2021a} para mais informações sobre a conversão eficiente de números decimais em pontos flutuantes.
\end{obs}

Observemos que o erro de arredondamento varia conforme o número dado, podendo ser zero no caso de $x = fl(x)$. Comumente, utiliza-se o \emph{épsilon de máquina}\index{épsilon de máquina} como uma aproximação desse erro. O épsilon de máquina é definido como a distância entre o número 1 e seu primeiro sucessor em ponto flutuante. Temos

\begin{lstlisting}
ld = unpackBitsDouble(1)
ld
\end{lstlisting}

\begin{verbatim}
[0, 0, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0]
\end{verbatim}

\begin{lstlisting}
ld[63] = 1
x = packBitsDouble(ld)
x-1
\end{lstlisting}

\begin{verbatim}
2.220446049250313e-16
\end{verbatim}


Ou seja, o épsilon de máquina é
\begin{equation}
  \mathrm{eps} := 2^{-52} \approx 2.22\times 10^{-16}.
\end{equation}

\begin{obs}
  O método \href{https://numpy.org/doc/stable/reference/generated/numpy.finfo.html}{\lstinline{numpy.finfo}} pode ser usado para obtermos várias informações sobre o sistema de números em ponto flutuante. Por exemplo, temos

\begin{lstlisting}
import numpy as np
finfo = np.finfo(np.double)
finfo.eps
\end{lstlisting}

\begin{verbatim}
2.220446049250313e-16
\end{verbatim}

\begin{lstlisting}
finfo.min
\end{lstlisting}

\begin{verbatim}
-1.7976931348623157e+308
\end{verbatim}

\begin{lstlisting}
finfo.max
\end{lstlisting}

\begin{verbatim}
1.7976931348623157e+308
\end{verbatim}

\end{obs}

A aritmética em ponto flutuante requer arredondamentos sucessivos de números. Por exemplo, a computação da soma de dois números dados $x$ e $y$ é feita a partir de suas representações em ponto flutuante $fl(x)$ e $fl(y)$. Então, computa-se $z = fl(x)+fl(y)$ e o resultado é $fl(z)$. Observe, inclusive que $fl(x+y)$ pode ser diferente de $fl(fl(x)+fl(y))$. Por exemplo

\begin{lstlisting}
0.1 + 0.2 == 0.3
\end{lstlisting}

\begin{verbatim}
False
\end{verbatim}

\subsection{Exercícios Resolvidos}

\begin{exeresol}
  No sistema de complemento 2 de 8~{\it bits}, forneça o registro que representa os seguintes números inteiros:
  \begin{enumerate}[a)]
  \item 1
  \item -1
  \item 15
  \item -15
  \end{enumerate}
\end{exeresol}
\begin{resol}
  A seguinte função, obtém o registro de complemento 2 de 8-{\it bits} de um dado número inteiro x.

\begin{lstlisting}
def unpackBitsInt8(x):
  ld = 8*[0]
  if (x < 0):
      ld[7] = 1
      x += 2**(7)
  for i in range(7):
      ld[i] = x % 2
      x //= 2
  return ld
\end{lstlisting}

Usando-a, obtemos os seguintes resultados:

\begin{lstlisting}
# a) 1
unpackBitsInt8(1)
\end{lstlisting}

\begin{verbatim}
[1, 0, 0, 0, 0, 0, 0, 0]
\end{verbatim}

\begin{lstlisting}
# b) -1
unpackBitsInt8(-1)
\end{lstlisting}

\begin{verbatim}
[1, 1, 1, 1, 1, 1, 1, 1]
\end{verbatim}

\begin{lstlisting}
# c) 15
unpackBitsInt8(15)
\end{lstlisting}

\begin{verbatim}
[1, 1, 1, 1, 0, 0, 0, 0]
\end{verbatim}

\begin{lstlisting}
unpackBitsInt8(-15)
\end{lstlisting}

\begin{verbatim}
[1, 0, 0, 0, 1, 1, 1, 1]
\end{verbatim}

\end{resol}

\begin{exeresol}
  Qual é o número decimal positivo mais próximo de zero que pode ser representado como um ponto flutuante de 64-{\it bits}. Também, forneça seu registro.
\end{exeresol}
\begin{resol}
  Um registro em ponto flutuante de 64-{\it bits} tem a forma
  \begin{equation}
    [s ~ | ~ c_{10} ~ c_9 ~ \ldots ~ c_{0} ~ | ~ m_1 ~ m_2 ~ \ldots ~ m_{52}]
  \end{equation}
  e representa o número
  \begin{equation}
    x = (-1)^s M\cdot 2^{c - 1023},
  \end{equation}
  onde $M$ é chamada de mantissa e $c$ da característica, as quais são definidas por
  \begin{align}
    M &:= (1,m_1m_2m_3\ldots m_{52})_2,\\
    c &:= (c_{10}\ldots c_2c_1c_0)_2.
  \end{align}
  Tendo em vista que o registro nulo é reservado para o número decimal zero, temos que o número positivo mais próximo de zero é obtido com sinal $s=0$, a mantissa $M=1$ e a característica $c=1$, no que obtemos o decimal
  \begin{align}
    x &= 2^{-1022}\\
      &\approx 2.2250738585072014e-308
  \end{align}
  Seu registro é
  \begin{equation}
    [0 ~ | ~ 0 ~ 0 ~ \ldots ~ 1 ~ | ~ 0 ~ 0 ~ \ldots ~ 0]
  \end{equation}

  O resultado pode ser verificado com os seguintes comandos:

\begin{lstlisting}
import numpy as np
import struct
x = np.finfo(np.double).tiny; x
\end{lstlisting}

\begin{verbatim}
2.2250738585072014e-308
\end{verbatim}

\begin{lstlisting}
''.join(f'{c:08b}' \
  for c in struct.pack('!d', x))
\end{lstlisting}

\begin{verbatim}
'0000000000010000
0000000000000000
0000000000000000
0000000000000000'
\end{verbatim}

\end{resol}

\begin{exeresol}
  Em aplicações que não necessitam de muita precisão, a representação de números decimais no sistema de ponto flutuante de 32~{\it bits} é mais eficiente (no sentido de velocidade de processamento computacional). Neste sistema, um registro de 32-{\it bits}
  \begin{equation}
    [s ~ | ~ c_7 ~ c_6 ~ \ldots ~ c_0 ~ | ~ m_1 ~ m_2 ~ \ldots ~ m_{23}]
  \end{equation}
  representa o número
  \begin{equation}
    x = (-1)^s\cdot M\cdot 2^{c-127}
  \end{equation}
  onde,
  \begin{gather}
    M = (1,m_1m_2\ldots m_{23})_2\\
    c = (c_7c_6\ldots c_0)_2
  \end{gather}
  \begin{enumerate}[a)]
  \item Forneça o registro do ponto flutuante de 32-{\it bits} que representa o número $42.5$.
  \item Qual é o sucessor em ponto flutuante de 32-{\it bits} do número decimal 1. Forneça, também, o épsilon de máquina deste sistema.
  \end{enumerate}
\end{exeresol}
\begin{resol}
  \begin{enumerate}[a)]
  \item O registro do ponto flutuante de 32-{\it bits} que representa o número $42.5$ pode ser computado com o seguinte código:

\begin{lstlisting}
x = 42.5
ld = 32*[0]
c = int(np.log2(x) + 127)
m = x/2**(c-127)
for i in range(8):
  ld[8-i] = c % 2
  c //= 2
m -= 1
for i in range(23):
  m *= 2
  ld[9+i] = int(m)
  m %= 1
ld
\end{lstlisting}

\begin{verbatim}
[0, 1, 0, 0, 0, 0, 1, 0,
0, 0, 1, 0, 1, 0, 1, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0]
\end{verbatim}

Alternativamente, pode-se obter o registro como segue:

\begin{lstlisting}
''.join(f'{c:08b}' \
for c in struct.pack('!f', 42.5))
\end{lstlisting}

\begin{verbatim}
'0100001000101010
0000000000000000'
\end{verbatim}

  \item No sistema de ponto flutuante de 32-{\it bits}, o sucessor de 1 tem o registro
    \begin{equation}
      [0 ~ | ~ 0 ~ 1 ~ 1 ~ \ldots ~ 1 ~ | ~ 0 ~ 0 ~ \ldots ~ 0 ~ 1]
    \end{equation}
    donde, sua mantissa é $m = 1 + 2^{-23}$, característica $c = 127$ e corresponde ao número decimal
    \begin{gather}
      x = (-1)^0\cdot (1 + 2^{-23})\cdot 2^{127-127}\\
      x = 1 + 2^{-23}
    \end{gather}
    Portanto, o épsilon de máquina neste sistema é
    \begin{align}
      \mathrm{eps} &= x - 1\\
                   &= 2^{-23}
    \end{align}

\begin{lstlisting}
np.float32(2**-23)
\end{lstlisting}

\begin{verbatim}
1.1920929e-07
\end{verbatim}

  \end{enumerate}
\end{resol}

\subsection{Exercícios}

\begin{exer}
  Considerando a representação de complemento de 2 de números inteiros, obtenha os registros de $8$-{\it bits} dos seguintes números:
  \begin{enumerate}[a)]
  \item $17$
  \item $-17$
  \item $32$
  \item $-32$
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~[10001000]; b)~[11110111]\\
  c)~[00000100]; d)~[00000111]
\end{resp}

\begin{exer}
  Considerando a representação de complemento de 2 de números inteiros, obtenha os registros de $16$-{\it bits} dos seguintes números:
  \begin{enumerate}[a)]
  \item $1024$
  \item $-1024$
  \end{enumerate}
\end{exer}
\begin{resp}
    a)~[0000000000100000]; \\
    b)~[0000000000111111];
\end{resp}

\begin{exer}
  Considerando a representação de complemento de 2 de números inteiros, qual é o maior número que pode ser representado por um registro de $32$-{\it bits} da forma
  \begin{equation}
    [1 ~ 0 ~ b_2 ~ b_3 ~ b_4 ~ \cdots ~ b_{30} ~ 1],
  \end{equation}
onde $b_i \in \{0, 1\}$, $i=2, 3, 4, \cdots, 30$.
\end{exer}
\begin{resp}
  $[10111 \ldots 11] \sim -3$
\end{resp}

\begin{exer}
  Obtenha os registros em ponto flutuante de $64$-{\it bits} dos seguintes números:
  \begin{enumerate}[a)]
  \item $-1.25$
  \item $3$
  \end{enumerate}
\end{exer}
\begin{resp}
    a)~$[1 ~ | ~ 0 ~ 1 ~ 1 ~ \ldots ~ 1 ~ | ~ 1 ~ 0 ~ 1 ~ 0 ~ 0 ~ \ldots ~ 0]$;\\
    b)~$[0 ~ | ~ 1 ~ 0 ~ 0 ~ \ldots ~ 0 ~ | ~ 1 ~ 0 ~ 0 ~ \ldots ~ 0]$
\end{resp}

\begin{exer}
  Assumindo o sistema de ponto flutuante de $32$-{\it bits}, obtenha o registro e o erro de arredondamento na representação dos seguintes números decimais:
  \begin{enumerate}[a)]
  \item $0.1$
  \item $10.1$
  \item $100.1$
  \end{enumerate}
\end{exer}
\begin{resp}
  \begin{enumerate}[a)]
  \item % a)
\begin{verbatim}
  [0, 0, 1, 1, 1, 1, 0, 1,
  1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 0,
  1, 1, 0, 0, 1, 1, 0, 1]
\end{verbatim}

$|0.1 - fl(0.1)| \approx 1.5e^{-9}$

\item % b)
\begin{verbatim}
[0, 1, 0, 0, 0, 0, 0, 1,
0, 0, 1, 0, 0, 0, 0, 1,
1, 0, 0, 1, 1, 0, 0, 1,
1, 0, 0, 1, 1, 0, 1, 0]
\end{verbatim}
$|10.1 - fl(10.1)| \approx 3.8e^{-7}$

\item % c)
\begin{verbatim}
[0, 1, 0, 0, 0, 0, 1, 0,
1, 1, 0, 0, 1, 0, 0, 0,
0, 0, 1, 1, 0, 0, 1, 1,
0, 0, 1, 1, 0, 0, 1, 1]
\end{verbatim}
$|100.1 - fl(100.1)| \approx 1.5e^{-6}$
  \end{enumerate}
\end{resp}

\ifisbook
\subsubsection{Respostas}
\shipoutAnswer
\fi

%%% SECTION %%%

\section{Notação Científica e Arredondamento}\label{cap_aritm_sec_notcient}

Enquanto que a manipulação computacional de números decimais é feita usando-se da aritmética em ponto flutuante, a interpretação dos parâmetros dos problemas de interesse e seus resultados é normalmente feita com poucos dígitos. Nesta seção, introduziremos algumas notações que serão utilizadas ao longo deste material.

A \hl{\emph{notação científica}} é a representação de um dado número na forma
\begin{equation}
  \hleq{d_{n}\ldots d_2d_1d_0,d_{-1}d_{-2}d_{-3}\ldots \times 10^{E}},
\end{equation}
onde $d_i$, $i=n, \ldots, 1, 0, -1, \ldots$, são algarismos da base 10. A parte à esquerda do sinal $\times$ é chamada de \hl{\emph{mantissa}} do número e $E$ é chamado de \hl{\emph{expoente}} (ou ordem de grandeza).

\begin{ex}\label{ex:notacao_cientifica}
  O número $31.515$ pode ser representado em notação científica das seguintes formas
  \begin{align}
    31.415\times 10^0 &= 3.1415\times 10^{1} \\
                      &= 314.15\times 10^{-1} \\
                      &= 0.031415\times 10^{3},
  \end{align}
  entre outras tantas possibilidades.

  \hl{Em {\python}, usa-se a letra \texttt{e} para separar a mantissa do expoente} na notação científica. Por exemplo

\begin{lstlisting}
# 31.415 X 10^0
31.415e0
\end{lstlisting}

\begin{verbatim}
31.515
\end{verbatim}

\begin{lstlisting}
# 3.1415 X 10^1
3.1415e1
\end{lstlisting}

\begin{verbatim}
31.515
\end{verbatim}

\begin{lstlisting}
# 314.15 X 10^-1
314.15e-1
\end{lstlisting}

\begin{verbatim}
31.515
\end{verbatim}

\begin{lstlisting}
# 0.031415 X 10^3
0.031415e3
\end{lstlisting}

\begin{verbatim}
31.415
\end{verbatim}

\end{ex}

No exemplo anterior (Exemplo~\ref{ex:notacao_cientifica}), podemos observar que a representação em notação científica de um dado número não é única. Para contornar isto, introduzimos a \colorbox{yellow}{\emph{notação científica normalizada}}, a qual tem a forma
\begin{equation}
  \hleq{d_0,d_{-1}d_{-2}d_{-3}\ldots\times 10^{E}},
\end{equation}
com $d_0 \neq 0$\endnote{No caso do número zero, temos $d_0=0$.}.

\begin{ex}
  O número $31.415$ representado em notação científica normalizada é $3.1415\times 10^{1}$.

  Em {\python}, podemos usar de \texttt{strings} formatadas para imprimir um número em notação científica normalizada. Há várias especificações de formatação disponíveis\endnote{Consulte na \textit{web} por \href{https://docs.python.org/3/library/string.html\#format-specification-mini-language}{Python Docs:String: Format Specification Mini-Language} para uma lista completa.}. Por exemplo, temos

\begin{lstlisting}
x = 31.415
print(f"{x:e}")
\end{lstlisting}

\begin{verbatim}
3.141500e+01
\end{verbatim}

\end{ex}

Como vimos na seção anterior, usamos da aritmética de ponto flutuante nas computações, com a qual os números são representados com muito mais dígitos dos quais costumeiramente estamos interessados na interpretação dos resultados. Isto nos leva de volta a questão do arredondamento.

Dizemos que \hl{um número está representado com $n$ \emph{dígitos significativos}} (na notação científica normalizada) \hl{quando está escrito na forma}
\begin{equation}
  \hleq{d_0,d_{1}d_{2}\ldots d_{n-1}\times 10^{E}},
\end{equation}
com $d_0\neq 0$.

\begin{ex}
  Estudamos as seguintes representações do número $31.415$:
  \begin{enumerate}[a)]
  \item com 5 dígitos significativos

\begin{lstlisting}
x = 31.415
print(f"{x:.4e}")
\end{lstlisting}

\begin{verbatim}
3.1415e+01
\end{verbatim}

  \item com 6 dígitos significativos

\begin{lstlisting}
print(f"{x:.5e}")
\end{lstlisting}

\begin{verbatim}
3.14150e+01
\end{verbatim}

\item com 4 dígitos significativos

\begin{lstlisting}
print(f"{x:.3e}")
\end{lstlisting}

\begin{verbatim}
3.142e+01
\end{verbatim}

Neste último caso, fez-se necessário arredondar o número.
  \end{enumerate}
\end{ex}

\subsection{Arredondamento}

Observamos que pode ocorrer a necessidade de se arredondar um número para obter sua representação com um número finito de dígitos significativos. Por exemplo, para representarmos o número $x=3.1415\times 10^1$ com 3 dígitos significativos, precisamos determinar de que forma vamos considerar a contribuição de seus demais dígitos a direita. Isto, por sua vez, é determinado pelo tipo de arredondamento que iremos utilizar.

O tipo de arredondamento mais comumente utilizado é o chamado \hl{\emph{arredondamento por proximidade com desempate par}}. Neste, \hl{a representação escolhida é aquela mais próxima do número dado}. Por exemplo, a representação de 
\begin{equation}
  x=3.1415\times 10^1
\end{equation}
com três dígitos significativos é 
\begin{equation}
  x=3.14\times 10^{1}. 
\end{equation}
Agora, sua representação com apenas dois dígitos significativos é
\begin{equation}
  x=3.1\times 10^{1}.
\end{equation}
\hl{No caso de empate}, usa-se a seguinte regra: \hl{1) se o último dígito significativo ser par, este é mantido; 2) se o último dígito significativo ser ímpar, este é acrescido de uma unidade}. Por exemplo, no caso do número $x=3.1415\times 10^1$, sua representação com 4 dígitos significativos é
\begin{equation}
  x = 3.142\times 10^1.
\end{equation}

\begin{obs}\label{obs:arredondamento_ieee754}
  \hl{O arredondamento por proximidade com desempate par é o padrão do IEEE 754}\endnote{Para mais detalhes, consulte \href{https://en.wikipedia.org/wiki/IEEE\_754\#Rounding\_rules}{IEEE 754: Wikipedia}.}. No entanto, devemos lembrar que a maioria dos números decimais não tem representação exata no sistema de ponto flutuante. Por exemplo,

\begin{lstlisting}
x = 31.415
print(f'{x:.3e}')
\end{lstlisting}

\begin{verbatim}
3.141e+01
\end{verbatim}

  Embora o arrendamento não seja o esperado, o que ocorre é que $x = 31.415$ não tem representação exata em ponto flutuante, de fato

\begin{lstlisting}
print(f'{x:.25e}')
\end{lstlisting}

\begin{verbatim}
3.1414999999999999147348717e+01
\end{verbatim}
\end{obs}

No restante deste material estaremos assumindo a notação científica normalizada com arredondamento por proximidade com desempate par.

\subsection{Exercícios Resolvidos}

\begin{exeresol}
  Faça o cálculo exato e a computação de
  \begin{equation}
    \frac{0.33411\times 10^2 - 271.28\times 10^{-1}}{2000\times 10^{-3}}
  \end{equation}
  Forneça os resultados com 4 dígitos significados.
\end{exeresol}
\begin{resol}
  \begin{itemize}
  \item Por cálculo exato.
    \begin{gather}
      \frac{0.33411\times 10^2 - 271.28\times 10^{-1}}{2000\times 10^{-3}}\\
      = \frac{334.11\times 10^{-1} - 271.28\times 10^{-1}}{2\times 10^0}\\
      = \frac{63.83\times 10^{-1}}{2}\\
      = 31.415\times 10^{-1}
    \end{gather}
    Arredondando o resultado para 4 dígitos significativos, obtemos $3.142$.
  \item Por computação.

\begin{lstlisting}
x = (0.33411e2 - 271.28e-1)/2000e-3
x
\end{lstlisting}

\begin{verbatim}
3.1415000000000006
\end{verbatim}

\begin{lstlisting}
print(f'{x:.3e}')
\end{lstlisting}

\begin{verbatim}
3.142e+00
\end{verbatim}

  \end{itemize}
\end{resol}

\begin{exeresol}
  Obtenha os arredondamentos dos seguintes números decimais para quantidade de dígitos significativos indicada em cada caso. Então, compare com a computada em ponto flutuante.
  \begin{enumerate}[a)]
  \item $2.7128$ com 4 dígitos significativos.
  \item $2.7128$ com 2 dígitos significativos.
  \item $1.9910$ com 3 dígitos significativos.
  \item $1.9910$ com 2 dígitos significativos.
  \item $5.5555$ com 4 dígitos significativos.
  \item $5.6555$ com 4 dígitos significativos.
  \end{enumerate}
\end{exeresol}
\begin{resol}
  \begin{enumerate}[a)]
  \item $2.7128$ com 4 dígitos significativos = $2.713$

\begin{lstlisting}
f'{2.7128:.3e}'
\end{lstlisting}

\begin{verbatim}
'2.713e+00'
\end{verbatim}

    \item $2.7128$ com 2 dígitos significativos = $2.7$

\begin{lstlisting}
f'{2.7128:.1e}'
\end{lstlisting}

\begin{verbatim}
'2.7e+00'
\end{verbatim}

    \item $1.9910$ com 3 dígitos significativos = $1.99$

\begin{lstlisting}
f'{1.9910:.2e}'
\end{lstlisting}

\begin{verbatim}
'1.99e+00'
\end{verbatim}

\item $1.9910$ com 2 dígitos significativos = $2.0$
    
\begin{lstlisting}
f'{1.9910:.1e}'
\end{lstlisting}

\begin{verbatim}
'2.0e+00'
\end{verbatim}
        
  \item $5.5555$ com 4 dígitos significativos = $5.556$
    
\begin{lstlisting}
f'{5.5555:.3e}'
\end{lstlisting}

\begin{verbatim}
'5.556e+00'
\end{verbatim}
        
  \item $5.6555$ com 4 dígitos significativos = $5.556$
    
\begin{lstlisting}
f'{5.6555:.3e}'
\end{lstlisting}

\begin{verbatim}
'5.655e+00'
\end{verbatim}
        
  \end{enumerate}
\end{resol}

\subsection{Exercícios}

\begin{exer}
  Obtenha a representação dos seguintes números decimais em notação científica normalizada com a quantidade de dígitos indicada em cada caso. Então, compare com o arredondamento computado em ponto flutuante. Caso haja diferença, explique.
  \begin{enumerate}[a)]
  \item $\pi$ com 6 dígitos significativos.
  \item $\pi/10$ com 6 dígitos significativos.
  \item $\sqrt{2}/\sqrt{3}$ com 7 dígitos significativos.
  \end{enumerate}
\end{exer}
\begin{resp}
  a) $3.14159\times 10^0$, \lstinline+3.14159e+00+; b) $3.14159\times 10^{-1}$, \lstinline+3.14159e-01+; c) $8.164922\times 10^{-1}$, \lstinline+8.164966e-01+
\end{resp}

\begin{exer}
  Compute a seguinte expressão
  \begin{equation}
    \frac{\sqrt{\pi} - \ln(0.9)}{75\cos\left(\frac{\pi}{4}\right)}.
  \end{equation}
  Forneça a resposta com 7 dígitos significativos.
\end{exer}
\begin{resp}
  $3.540841\times 10^{-1}$
\end{resp}

\begin{exer}
  Forneça o arredondamento dos seguintes números decimais para 2 dígitos significativos. Então, compare com o arrendamento computado em ponto flutuante. Caso haja diferença, explique.
  \begin{enumerate}[a)]
  \item $0.625$
  \item $0.615$
  \item $0.635$
  \end{enumerate}
\end{exer}
\begin{resp}
  a) $6.2\times 10^{-1}$, \lstinline+6.2e-01+; b) $6.2\times 10^{-1}$, \lstinline+6.1e-01+; c) $6.4\times 10^{-1}$; \lstinline+6.4e-01+
\end{resp}

\begin{exer}
  Seja $f_s$ a função que recebe número decimal e retorna sua aproximação por arrendamento com 2 dígitos significativos. Calcule
  \begin{enumerate}[a)]
  \item $f_s(2\pi - e)$
  \item $2f_s(\pi) - f_s(e)$
  \item Por que $f_s(2\pi - e) \neq  2f_s(\pi) - f_s(e)$?
  \end{enumerate}
\end{exer}
\begin{resp}
  a) $3.5$; b) $3.6$; c) Operar sobre números arredondados acarreta perda de exatidão.
\end{resp}


\begin{exer}
  Explique o porquê de

\begin{lstlisting}
np.sqrt(3)**2 == 3
\end{lstlisting}

\begin{verbatim}
False
\end{verbatim}

\end{exer}
\begin{resp}
  Dica: $\sqrt{3}$ não tem representação exata em ponto flutuante.
\end{resp}

\ifisbook
\subsubsection{Respostas}
\shipoutAnswer
\fi

%%% SECTION %%%

\section{Tipos e Medidas de Erros}\label{cap_aritm_sec_erros}

Ao utilizarmos computadores na resolução de problemas matemáticos, acabamos obtendo soluções aproximadas. A diferença entre a solução exata e a solução aproximada computada é chamada de erro. O erro é comumente classificado nas seguintes duas categorias:
\begin{itemize}
\item \hl{\emph{Erro de arredondamento}}

  Este é o erro que ocorre na representação aproximada de números na máquina.
  
\item \hl{\emph{Erro de truncamento}}

  Este é o erro que ocorre na interrupção (truncamento) de um procedimento com infinitos passos.
\end{itemize}

\begin{ex}\normalfont{(\hl{Erro de Arredondamento}.)}\label{ex:erro_de_arredondamento}
  O erro de arredondamento em aproximar $\pi$ por $3.1415\times 10^0$ é de aproximadamente $9.3\times 10^{-5}$.
  
\begin{lstlisting}
import numpy as np
np.pi - 3.1415e0
\end{lstlisting}

\begin{verbatim}
9.265358979293481e-05    
\end{verbatim}
  
\end{ex}

\begin{ex}\normalfont{(\hl{Erro de Truncamento}.)}\label{ex:erro_de_truncamento}
  Consideramos a seguinte série numérica $\sum_{n=0}^\infty 1/n! = e \approx 2.7183\times 10^0$. Ao computarmos esta série no computador, precisamos truncá-la em algum $n$ suficientemente grande. Por exemplo, truncando a série em seu nono termo, temos
  \begin{align}
    \sum_{n=0}^\infty \frac{1}{n!} &\approx \frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + \cdots + \frac{1}{8!} \\
    &\approx 2.71827876984127 =: \tilde{e}.
  \end{align}

  
\begin{lstlisting}
import math
x = 0
for n in range(9):
  x += 1./math.factorial(n)
print(math.fabs(math.e - x))
\end{lstlisting}
  
A diferença $|e - \tilde{e}| \approx 3\times 10^{-6}$ é o erro de truncamento associado.
\end{ex}

Suponhamos, agora, que $x$ seja o valor exato (valor esperado) de uma quantidade de interesse e $\tilde{x}$ o valor computado (aproximação de $x$). Em matemática numérica, utilizamos frequentemente as seguintes medidas de erro:
\begin{itemize}
  \item \hl{\emph{Erro absoluto}}:
    \begin{equation}
      \hleq{\varepsilon_{\text{abs}} := |x - \tilde{x}|}.
    \end{equation}
  \item \hl{\emph{Erro relativo}}:
    \begin{equation}
      \hleq{\varepsilon_{\text{rel}} := \frac{|x - \tilde{x}|}{|x|}\left(\times 100\%\right)}.
    \end{equation}
\end{itemize}

A vantagem do erro relativo é em levar em conta a ordem de grandeza da quantidade $x$.

\begin{ex}\label{ex:medidas_de_erros}
  Estudamos os seguintes casos:
  \begin{enumerate}[a)]
  \item $x=1.0$ e $\tilde{x} = 1.1$:
    \begin{align}
      \varepsilon_{\text{abs}} &= |x - \tilde{x}| \\
                        &= |1.0 - 1.1|\\
                        &= |-0.1|\\
                        &= 1\times 10^{-1}.\\
      \varepsilon_{\text{rel}} &= \frac{|x - \tilde{x}|}{|x|} \\
                        &= \frac{|1.0-1.1|}{|1.0|}\\
                        &= \frac{|-0.1|}{|1.0|}\\
                        &= 1\times 10^{-1} = 10\%.
    \end{align}
    
\begin{lstlisting}
x = 1.0
xa = 1.1
eabs = abs(x - xa); eabs
\end{lstlisting}

\begin{verbatim}
0.10000000000000009
\end{verbatim}

\begin{lstlisting}
erel = eabs/abs(x)
erel
\end{lstlisting}

\begin{verbatim}
0.10000000000000009
\end{verbatim}

    
  \item $x=1000.0$ e $\tilde{x} = 1100.0$:
    \begin{align}
      \varepsilon_{\text{abs}} &= |x - \tilde{x}| \\
                        &= |1000.0 - 1100.0|\\
                        &= 1\times 10^2.\\
      \varepsilon_{\text{rel}} &= \frac{|x - \tilde{x}|}{|x|} \\
                        &= \frac{|1000.0 - 1100.0|}{|1000.0|}\\
                        &= \frac{|-100.0|}{|1000.0|}\\
                        &= 1\times 10^{-1} = 10\%.
    \end{align}
    
\begin{lstlisting}
x = 1000.0; xa = 1100.0
eabs = abs(x - xa); eabs
\end{lstlisting}

\begin{verbatim}
100.0
\end{verbatim}

\begin{lstlisting}
erel = eabs/abs(x); erel
\end{lstlisting}

\begin{verbatim}
0.1
\end{verbatim}
    
  \end{enumerate}
\end{ex}

Outra \hl{medida de erro} comumente empregada é o \hl{\emph{número de dígitos significativos corretos}}. Dizemos que $\tilde{x}$ aproxima $x$ com $n$ dígitos significativos corretos, quando
\begin{equation}
  \hleq{\underbrace{\frac{|x - \tilde{x}|}{|x|}}_{\varepsilon_{\text{rel}}} < 5\times 10^{-n}}.
\end{equation}
Isso significa que ao arredondarmos $x$ e $\tilde{x}$ ambos com $n$ dígitos, obtemos o mesmo resultado.

\begin{ex}\label{ex:numdigsigcorr}
  Estudamos os seguintes casos:
  \begin{itemize}
  \item $x=2$ e $\tilde{x} = 2.4$
    \begin{equation}
      \varepsilon_{\text{rel}} = 0.2 < 5\times 10^{-1}
    \end{equation}
    Temos que $\tilde{x} = 2.4$ aproxima $x = 2$ com um dígito significativo correto. Note que ambos são iguais quando os arredondamos para um dígito.
  \item $x=2$ e $\tilde{x} = 2.5$
    \begin{equation}
      \frac{|x - \tilde{x}|}{|x|} = 0.25 < 5\times 10^{-1}
    \end{equation}
    Temos que $\tilde{x}=2.5$ é uma aproximação com $1$ dígito significativo correto de $x=2$. Note que ambos são iguais quando os arredondamos para um dígito.
  \item $x=1$ e $\tilde{x} = 1.5$:
    \begin{equation}
      \frac{|x - \tilde{x}|}{|x|} = 0.5 < 5\times 10^{0},
    \end{equation}
    Temos que $\tilde{x}=1.5$ é uma aproximação com zero dígito significativo correto de $x=1$. Note que ao arredondarmos\endnote{Assumindo o arredondamento por proximidade com desempate par.} $\tilde{x}$ para um dígito, obtemos $\tilde{x}\approx 2$, enquanto que $x=1$.
  \end{itemize}
\end{ex}

\subsection{Propagação de Erros}

Nesta seção, vamos introduzir uma \hl{estimativa para a propagação de erros (de arredondamento) na computação de um problema}. Para tando, vamos considerar o caso de se calcular o valor de uma dada função $f$ em um dado ponto $x$, i.e. queremos calcular $y$ com
\begin{equation}\label{eq:properros_aux1}
  y = f(x).
\end{equation}
Agora, assumindo que $x$ seja conhecido com um erro $\varepsilon(x)$, este se propaga no cálculo da $f$, levando a um erro $\varepsilon(y)$ no valor calculado de $y$. Ou seja, temos
\begin{equation}\label{eq:properros_aux2}
  \hleq{y + \varepsilon(y) = f(x+\varepsilon(x))}.
\end{equation}
Denotamos $\varepsilon_{\text{abs}}(x) = |\varepsilon(x)|$ o erro absoluto associado a $x$ e $\varepsilon_{\text{abs}}(y) = |\varepsilon(y)|$ o erro absoluto associado a $y$.

Nosso objetivo é estimar $\varepsilon_{\text{abs}}(y)$ com base em $\varepsilon_{\text{abs}}(x)$. Para tanto, tomamos a aproximação de $f(x+\varepsilon(x))$ dada pelo polinômio de Taylor de grau $1$ de $f$ em torno de $x$, i.e.
\begin{equation}
  f(x+\varepsilon(x)) = f(x) + f'(x)\varepsilon(x) + O\left(\varepsilon^2(x)\right).
\end{equation}
Então, de \eqref{eq:properros_aux1} e \eqref{eq:properros_aux2}, temos
\begin{equation}
  \varepsilon(y) = f'(x)\varepsilon(x) + O(\varepsilon^2(x)).
\end{equation}
Daí, passando ao valor absoluto e usando a desigualdade triangular, obtemos
\begin{align}
  \varepsilon_{\text{abs}}(y) &= \left|f'(x)\varepsilon(x) + O(\varepsilon^2(x))\right|\\
                              &\leq |f'(x)|\varepsilon_{\text{abs}}(x) + O\left(\varepsilon_{\text{abs}}^2(x)\right).
\end{align}
Deste resultado, obtemos a seguinte estimativa de propagação de erro
\begin{equation}\label{eq:estproperro_1}
  \hleq{\varepsilon_{\text{abs}}(y) \approx |f'(x)|\varepsilon_{\text{abs}}(x)}.
\end{equation}

\begin{ex}\label{ex:properro_1}
  Consideramos o problema em se calcular
  \begin{equation}
    y = f(x) = x^2\sen(x)
  \end{equation}
  com $x=\pi/3 \pm 0.1$. Usando \eqref{eq:estproperro_1} para estimarmos o erro absoluto $\varepsilon_{\text{abs}}(y)$ no cálculo de $y$ com base no erro absoluto $\varepsilon_{\text{abs}}(x)=0.1$, calculamos
  \begin{align}
    \varepsilon_{\text{abs}}(y) &= |f'(x)|\varepsilon_{\text{abs}}(x)\\
             &= |2x\sen(x) + x^2\cos(x)|\varepsilon_{\text{abs}}(x)\\
             &= 2.3621\times 10^{-1}.
  \end{align}

  
\begin{lstlisting}
import math
x = math.pi/3; eabsx = 0.1
eabsy = math.fabs(2*x*math.sin(x) \
  + x**2 * math.cos(x)) * eabsx
print(f"{eabsy:.4e}")
\end{lstlisting}

\begin{verbatim}
2.3621e-01
\end{verbatim}
  
  Com isso, concluímos que um erro em $x$ de tamanho $0.1$ é propagado no cálculo de $f(x)$, causando um erro pelo menos duas vezes maior em $y$. Também, podemos interpretar este resultado do ponto de vista do erro relativo. O erro relativo associado a $x$ é
  \begin{align}
    \varepsilon_{\text{rel}}(x) &= \frac{\varepsilon_{\text{abs}}(x)}{|x|}\\
                                &= \frac{0.1}{\pi/3}\\
                                &= 9.5493\times 10^{-2} \approx 10\%,
  \end{align}
  acarretando um erro relativo em $y$ de
  \begin{align}
    \varepsilon_{\text{rel}}(y) &= \frac{\varepsilon_{\text{abs}}(y)}{|y|}\\
                                &= \frac{\varepsilon_{\text{abs}}(y)}{|f(x)|} \\
                                &= 2.4872\times 10^{-2} \approx 25\%.
  \end{align}

  
\begin{lstlisting}
import math
x = math.pi/3; eabsx = 0.1
erelx = eabsx/math.fabs(x)
print(f"{erelx*100: .0f} %")
\end{lstlisting}

\begin{verbatim}
10 %
\end{verbatim}

\begin{lstlisting}
f = lambda x: x**2 * math.sin(x) 
df = lambda x: 2*x*math.sin(x) \
  + x**2 * math.cos(x)
eabsy = math.fabs(df(x)) * eabsx
erely = eabsy/math.fabs(f(x))
print(f"{erely*100: .0f} %")
\end{lstlisting}

\begin{verbatim}
25 %
\end{verbatim}
  
\end{ex}

Associada à estimativa \eqref{ex:properro_1}, temos
\begin{align*}
  \varepsilon_{\text{rel}}(y) &= \frac{\varepsilon_{\text{abs}}(y)}{|y|}\\
  &= \frac{|f'(x)|}{|y|}\varepsilon_{\text{abs}}(x)\\
  &= \frac{|x|\cdot |f'(x)|}{|f(x)|}\frac{\varepsilon_{\text{abs}}(x)}{|x|}\\
  &= \left|\frac{xf'(x)}{f(x)}\right|\varepsilon_{\text{rel}}(x).
\end{align*}
Desta última equação, definimos o \hl{\emph{número de condicionamento} de $f$}, denotado por
\begin{equation}
  \hleq{\kappa_f(x) := \left|\frac{xf'(x)}{f(x)}\right|}.
\end{equation}
Observamos que \hl{$\kappa_f(x)$ é a escala com que erros em $x$ são propagados no cálculo de $y = f(x)$}.

\begin{ex}\label{ex:numcond_1}
  O número de condicionamento da função $f(x) = x^2\sen(x)$ no ponto $x=\pi/3$ é calculado por
  \begin{align}
    \kappa_f(x) &= \left|\frac{xf'(x)}{f(x)}\right|\\
                &= \left|\frac{x\left[2x\sen(x)+x^2\cos(x)\right]}{x^2\sen(x)}\right|. 
  \end{align}
  Substituindo $x$ por $\pi/3$, obtemos
  \begin{equation}
    \kappa_f(\pi/3) = 2.6046.
  \end{equation}
  Observamos que o resultado é compatível com os obtidos no Exemplo \ref{ex:properro_1}.
  
  
\begin{lstlisting}
import math
f = lambda x: x**2 * math.sin(x) 
df = lambda x: 2*x*math.sin(x) \
  + x**2 * math.cos(x)
x = math.pi/3
kf = math.fabs(x*df(x)/f(x))
print(f"{kf:.4f}")
\end{lstlisting}

\begin{verbatim}
2.6046
\end{verbatim}
  
\end{ex}

A estimativa \eqref{eq:estproperro_1} pode ser generalizada para uma função de várias variáveis. No caso de uma função $y = f(x_1,x_2,\dotsc,x_n)$, temos
\begin{equation}\label{eq:estproperro_n}
  \hleq{\varepsilon_{\text{abs}}(y) = \sum_{k=1}^n \left|\frac{\p f}{\p x_k}\right|\varepsilon_{\text{abs}}(x_k)}.
\end{equation}

\begin{ex}\label{ex:properro_2}
  Consideremos o problema em se calcular
  \begin{equation}
    z = f(x,y) = x^2\sen(x)\cos(y)
  \end{equation}
  com
  \begin{gather}
    x = \frac{\pi}{3} \pm 0.1,\\
    y = \frac{\pi}{4} \pm 0.02.
  \end{gather}
  Usando \eqref{eq:estproperro_n} para estimarmos o erro absoluto $e_{\text{abs}}(z)$ no cálculo de $z$ com base nos erros absolutos $e_{\text{abs}}(x)=0.1$ e $e_{\text{abs}}(y)=0.02$, calculamos
  \begin{align}
    e_{\text{abs}}(z) &= \left|\frac{\p f}{\p x}\right|e_{\text{abs}}(x) + \left|\frac{\p f}{\p y}\right|e_{\text{abs}}(y)\\
                      &= |(2x\sen(x) + x^2\cos(x))\cos(y)|e_{\text{abs}}(x)\\
                      &+ \left|-x^2\sen(x)\sen(y)\right|e_{\text{abs}}(y)\\
                      &= 1.8046\times 10^{-1}.
  \end{align}
  
  
\begin{lstlisting}
import math
x = math.pi/3
eabsx = 0.1
y = math.pi/4
eabsy = 0.02
eabsz = math.fabs((2*x*math.sin(x) \
  + x**2*math.cos(x))*math.cos(y))*eabsx \
  + math.fabs(-x**2*math.sin(x)*math.sin(y))*eabsy
print(f"{eabsz:1.4e}")
\end{lstlisting}

\begin{verbatim}
1.8046e-01    
\end{verbatim}

\end{ex}


\subsection{Cancelamento Catastrófico}

No computador (com aritmética de ponto flutuante de 64-{\it bits}), as operações e funções elementares são computadas, usualmente, com um erro próximo do épsilon de máquina\index{épsilon de máquina} ($\mathrm{eps} \approx 10^{-16}$). Entretanto, em algumas situações estas operações fundamentais acarretam erros maiores, causando uma perda de precisão.

O chamado cancelamento catastrófico ocorre quando computamos a diferença entre dois números próximos. Para ilustrá-lo, considaremos os seguintes números
\begin{align}
  x &= 314150000001549,\\
  y &= 314150000002356.
\end{align}
Assumindo os arredondamentos de $x$ e $y$ com $12$ dígitos significativos, temos
\begin{align}
  \tilde{x} &= 314150000002000,\\
  \tilde{y} &= 314150000002000.
\end{align}
Os erros relativos associados às aproximações de $x$ e $y$ por $\tilde{x}$ e $\tilde{y}$ são
\begin{gather}
  e_{rel}(x) = \frac{|x-\tilde{x}|}{|x|} \approx 10^{-10}\%,\\
  e_{rel}(y) = \frac{|y-\tilde{y}|}{|y|} \approx 10^{-10}\%,
\end{gather}
respectivamente. Agora, temos
\begin{gather}
  y-x = 807,\\
  \tilde{y}-\tilde{x}=0.
\end{gather}
Ou seja, o erro relativo na aproximação de $y-x$ por $\tilde{y}-\tilde{x}$ é
\begin{align}
  e_{rel}(y-x) &= \frac{|(y-x)-(\tilde{y}-\tilde{x})|}{(y-x)}\\
               &= \frac{807}{807} = 100\%!
\end{align}

\begin{ex}\label{ex:cancela_1}
  Na tabela abaixo temos os erros em se computar
  \begin{equation}
    \frac{(1+x^4)-1}{x^4}
  \end{equation}
  para diferentes valores de $x$.
  
  \begin{center}
    \begin{tabular}{l|r}
      $x$     & erro \\\hline
      $1$      & $0$ \\
      $10^{-1}$ & $1.1\times 10^{-13}$\\
      $10^{-2}$ & $6.1\times 10^{-9}$\\
      $10^{-3}$ & $8.9\times 10^{-5}$\\
      $10^{-4}$ & $1.0\times 10^{0}$\\
      $10^{-5}$ & $1.0\times 10^{0}$\\\hline
    \end{tabular}
  \end{center}
  Observamos que, para o valor de $x=0.001$ o erro na computação já é da ordem de $10^{-5}$ e para valores de $x$ menores ou iguais a $0.0001$ o erro é catastrófico. Isto ocorre, pois se $x\leq 10^{-4}$, então $x^4 \leq 10^{-16} < \mathrm{eps}$ e, portanto, $(1+x^4)-1=0$.
\end{ex}

\begin{ex}\label{ex:solpq}
  Uma equação de segundo grau $ax^2 + bx + c = 0$ tem raízes
  \begin{align}
    x_1 &= \frac{-b + \sqrt{b^2 - 4ac}}{2a},\label{cap_aritm_sec_erros:eq:cancela_b}\\
    x_2 &= \frac{-b - \sqrt{b^2 - 4ac}}{2a}.\label{cap_aritm_sec_erros:eq:cancela_bx2}
  \end{align}
Entretanto, no caso de $b$ ser positivo, a fórmula \eqref{cap_aritm_sec_erros:eq:cancela_b} não é adequada para a computação da raiz $x_1$, pois pode ocorrer cancelamento catastrófico. Podemos contornar este problema reescrevendo \eqref{cap_aritm_sec_erros:eq:cancela_b} da seguinte forma
\begin{align}
  x_1 &= \frac{-b + \sqrt{b^2 - 4ac}}{2a}\cdot \frac{-b - \sqrt{b^2 - 4ac}}{-b - \sqrt{b^2 - 4ac}}\\
  &= \frac{b^2 - b^2 + 4ac}{2a(-b-\sqrt{b^2-4ac})}\\
  &= \frac{-2c}{b+\sqrt{b^2-4ac}}\label{cap_aritm_sec_erros:eq:bx1m},
\end{align}
a qual não sofre mais de cancelamento catastrófico. Observamos que também pode ocorrer cancelamento catastrófico no cálculo de $x_2$ pela fórmula \eqref{cap_aritm_sec_erros:eq:cancela_bx2}, no caso de $b$ ser negativo.
\end{ex}

\subsection{Exercícios Resolvidos}

\begin{exeresol}
  O número de Euler é definido por
  \begin{equation}
    e = \sum_{n=0}^\infty \frac{1}{n!}
  \end{equation}
  Determine o erro relativo da aproximação de $e$ pelo truncamento da série com 4 termos.
\end{exeresol}
\begin{resol}
  Denotamos $x = e$ e
  \begin{align}
    \tilde{x} &= \sum_{n=0}^3\frac{1}{n!}\\
              &= \frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!}\\
              &= \frac{1}{1} + \frac{1}{1} + \frac{1}{2} + \frac{1}{6}\\
              &= 2 + \frac{1}{2} + \frac{1}{6}\\
              &= \frac{16}{6}
  \end{align}
  O erro relativo é

\begin{lstlisting}
import math as m
x = m.e
xa = 16./6
eabs = m.fabs(x-xa)
erel = eabs/m.fabs(x)
print(f"{erel*100:1.1f} %")
\end{lstlisting}

\begin{verbatim}
1.9 %
\end{verbatim}

Concluímos que o erro relativo é de $1.9\%$.
\end{resol}

\begin{exeresol}
  Calcule o número de condicionamento $\kappa_f(x)$ para $f(x) = x^n$.
\end{exeresol}
\begin{resol}
  Calculamos o número de condicionamento como segue
  \begin{align}
    \kappa_f(x) &= \left|\frac{xf'(x)}{f(x)}\right|\\
                &= \left|\frac{x\cdot nx^{n-1}}{x^n}\right|\\
                &= \left|\frac{nx^n}{x^n}\right|\\
                &= n,\quad x\neq 0.
  \end{align}
\end{resol}

\begin{exeresol}
  Calcule as raízes do seguinte polinômio quadrático
  \begin{equation}
    p(x) = 10^{-6}x^2 + 10^2x + 3\times 10^{-3}
  \end{equation}
  com $10$ dígitos significativos corretos.
\end{exeresol}
\begin{resol}
  As raízes do polinômio quadrático podem ser calculados pela fórmula de Bhaskara
  \begin{align}
    x_1 &= \frac{-b + \sqrt{b^2 - 4ac}}{2a}\label{cap_aritm_sec_erros:eq:bx1}\\
    x_2 &= \frac{-b - \sqrt{b^2 - 4ac}}{2a}
  \end{align}
  No entanto, a computação da raiz $x_1$ sofre de cancelamento catastrófico. Para contornar este problema, usamos \eqref{cap_aritm_sec_erros:eq:bx1m}, i.e.
  \begin{equation}
    x_1 = \frac{-2c}{b + \sqrt{b^2 - 4ac}}
  \end{equation}

  
  Com o código

\begin{lstlisting}
import math as m

a = 1e-6
b = 1e2
c = 3e-3

delta = b**2 - 4*a*c

x1 = -2*c/(b + m.sqrt(delta))
x2 = (-b - m.sqrt(delta))/(2*a)

print(f"{x1:1.9e}, {x2:1.9e}")
\end{lstlisting}

obtemos as saídas

\begin{verbatim}
  x_1 = -3.000000000e-05
  x_2 = -1.000000000e+08
\end{verbatim}
  
\end{resol}

\subsection{Exercícios}

\begin{exer}\label{exer:erro_abs}
  Calcule o erro absoluto na aproximação de
  \begin{enumerate}[a)]
  \item $\pi$ por $3.14$.
  \item $10e$ por $27.18$.
  \end{enumerate}
  Forneça as respostas com $4$ dígitos significativos.
\end{exer}
\begin{resp}
  a)~$1.593\times 10^{-3}$; b)~$2.818\times 10^{-1}$;
\end{resp}

\begin{exer}\label{exer:erro_rel}
  Calcule o erro relativo na aproximação de
  \begin{enumerate}[a)]
  \item $\pi$ por $3.14$.
  \item $10e$ por $27.18$.
  \end{enumerate}
  Forneça as respostas em porcentagem.
\end{exer}
\begin{resp}
  a)~$0.051\%$; b)~$0.01\%$;
\end{resp}

\begin{exer}\label{exer:dig_corr}
  Com quantos dígitos significativos corretos
  \begin{enumerate}[a)]
  \item $3.13$ aproxima $\pi$?
  \item $27.21$ aproxima $10e$?
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~$3$; b)~$3$
\end{resp}


\begin{exer}
  Obtenha uma estimativa do erro de truncamento em se aproximar o valor de $\sen(1)$ usando-se $p_5(1)$, onde $p_5(x)$ é o polinômio de Taylor de grau 5 da função $\sen(x)$ em torno de $x=0$.
\end{exer}
\begin{resp}
  $1/6! \approx 1.4\times 10^{-3}$.
\end{resp}

\begin{exer}\label{exer:properro_abs1}
  Considerando que $x=2\pm 0.1$, estime o erro absoluto em se calcular $y = e^{-x^2}\cos(\pi x/3)$. Forneça a estimativa com $7$ dígitos significativos por arredondamento.
\end{exer}
\begin{resp}
  $2.002083\times 10^{-3}$
\end{resp}

\begin{exer}\label{exer:properro_abs2}
  Considerando que $x=2\pm 2\%$ e $y=1.5\pm 0.3$, estime o erro absoluto em se calcular $y = e^{-x^2}\cos(\pi y/3)$. Forneça a estimativa com $6$ dígitos significativos por arredondamento.
\end{exer}
\begin{resp}
  $5.75403\times 10^{-3}$
\end{resp}

\begin{exer}\label{exer:cancela_1}
  Considere a computação de
  \begin{equation}
    y = \frac{1 - \cos(h)}{h}
  \end{equation}
para $h=10^{-9}$. Compute o valor de $y$ reescrevendo esta expressão de forma a mitigar o cancelamento catastrófico. Forneça o valor computado de $y$ com $2$ dígitos significativos por arredondamento.
\end{exer}
\begin{resp}
  $5.0\times 10^{-10}$
\end{resp}

\ifisbook
\subsubsection{Respostas}
\shipoutAnswer
\fi

%%% SECTION %%%