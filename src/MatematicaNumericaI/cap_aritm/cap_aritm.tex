%Este trabalho está licenciado sob a Licença Atribuição-CompartilhaIgual 4.0 Internacional Creative Commons. Para visualizar uma cópia desta licença, visite http://creativecommons.org/licenses/by-sa/4.0/deed.pt_BR ou mande uma carta para Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

\chapter{Aritmética de Máquina}\label{cap_aritm}
\thispagestyle{fancy}

\begin{lstlisting}
  >>> 0.1 + 0.2 == 0.3
  False
\end{lstlisting}

\section{Sistema de Numeração Posicional}\label{cap_aritm_sec_sisnumpos}

\begin{flushright}
  [YouTube] | [Vídeo] | [Áudio] | \href{https://phkonzen.github.io/notas/contato.html}{[Contatar]}
\end{flushright}

Cotidianamente, usamos o sistema de numeração posicional na base decimal. Por exemplo, temos
\begin{equation}
  123,5 = 1\times 10^2 + 2\times 10^1 + 3\times 10^0 + 5\times 10^{-1},
\end{equation}
onde o algarismo/dígito 1 está na posição 2 (posição das centenas), o dígito 2 está na posição 1 (posição das dezenas) e o dígito 3 está na posição 0 (posição das unidades). Mais geralmente, temos a representação decimal
\begin{gather}
  \pm d_n\ldots d_2d_1d_0,d_{-1}d_{-2}d_{-3}\ldots \\
  := \pm \left(d_n\times 10^n + \cdots + d_2\times 10^2 + d_1\times 10^1 + d_0\times 10^0\right. \\
      \left. + d_{-1}\times 10^{-1} + d_{-2}\times 10^{-2} + d_{-3}\times 10^{-3} + \cdots\right),
\end{gather}
cujos os dígitos $d_i \in \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$, $i=n, \dotsc, 2, 1, 0, -1, -2, -3, \ldots$. Observamos que esta representação posicional pode ser generalizada para outras bases numéricas.

\begin{defn}\normalfont{(Representação posicional)}\label{defn:representacao_posicional}
  Dada uma base ${\color{blue}b}\in\mathbb{N}\setminus \{0\}$, definimos a representação
  \begin{gather}
    \pm (d_n\ldots d_2d_1d_0,d_{-1}d_{-2}d_{-3}\ldots)_{\color{blue}b} \\
    := \pm \left(d_n\times b^n + \cdots + d_2\times b^2 + d_1\times b^1 + d_0\times b^0\right. \\
      \left. + d_{-1}\times b^{-1} + d_{-2}\times b^{-2} + d_{-3}\times b^{-3} + \cdots\right),
  \end{gather}
onde os dígitos $d_i\in\{0, 1, \dotsc, {\color{blue}b}-1\}$\footnote{Para bases $b\geq 11$, usamos a representação dos dígitos maiores ou iguais a 10 por letras maiúsculas do alfabeto latino, i.e. $A=10$, $B=11$, $C=12$ e assim por diante.}, $i=n, \dotsc, 2, 1, 0, -1, -2, -3, \ldots$.
\end{defn}

\begin{ex}\normalfont{(Representação binária)}\label{ex:base_binaria}
  O número $(11010,101)_2$ está escrito na representação binária (base $b=2$). Da Definição~\ref{defn:representacao_posicional}, temos
  \begin{gather}
    (\stackrel{4}{1}~\stackrel{3}{1}~\stackrel{2}{0}~\stackrel{1}{1}~\stackrel{0}{0},\stackrel{-1}{~\,1}~\stackrel{-2}{~\,0}~\stackrel{-3}{~\,1})_2\\
    = 1\times 2^4 + 1\times 2^3 + 0\times 2^2 + 1\times 2^1 + 0\times 2^0\\
    + 1\times 2^{-1} + 0\times 2^{-2} + 1\times 2^{-3}\\
    = 26,625.
  \end{gather}

  \begin{lstlisting}
    >>> 1*2**4 + 1*2**3 + 0*2**2 + 1*2**1 + 0*2**0 + \
    ... 1*2**-1 + 0*2**-2 + 1*2**-3
    26.625
  \end{lstlisting}
\end{ex}

\subsection{Mudança de Base}

Um mesmo número pode ser representado em diferentes bases. A mudança de base da representação de um dado número pode ser feita de várias formas. De forma geral, se temos um número $x$ representado na base $b_1$ e queremos obter sua representação na base $b_2$, fazemos
\begin{enumerate}
\item Calculamos a representação do número $x$ na base decimal.
\item Da calculada representação decimal, calculamos a representação de $x$ na base $b_2$.
\end{enumerate}
Observamos que o passo 1. ($b \to 10$) segue imediatamente da Definição \ref{defn:representacao_posicional}. Agora, o passo 2. ($10\to b$), podemos usar o seguinte procedimento. Suponhamos que $x$ tenha a seguinte representação decimal
\begin{equation}
  d_nd_{n-1}d_{n-2}\ldots d_0,d_{-1}d_{-2}d_{-3}\ldots
\end{equation}
Então, separamos sua parte inteira $I = d_nd_{n-1}d_{n-2}\ldots d_0$ e sua parte fracionária $F = 0,d_{-1}d_{-2}d_{-3}\ldots$ ($x = I + F$). Então, usando de sucessivas divisões de $I$ pela base $b$ desejada, obtemos sua representação nesta mesma base. Analogamente, usando de sucessivas multiplicações de $F$ pela base $b$, obtemos sua representação nesta base. Por fim, basta somar as representações calculadas.

\begin{ex}
  Obtenha a representação em base quartenária ($b=4$) do número $(11010,101)_2$.
  \begin{enumerate}[1.]
  \item $b=2 \to 10$. 
    A representação de $(11010,101)_2$ segue direto da Definição \ref{defn:representacao_posicional} (veja, o Exemplo~\ref{ex:base_binaria}). Ou seja, temos
    \begin{gather}
      (\stackrel{4}{1}~\stackrel{3}{1}~\stackrel{2}{0}~\stackrel{1}{1}~\stackrel{0}{0},\stackrel{-1}{~\,1}~\stackrel{-2}{~\,0}~\stackrel{-3}{~\,1})_2 \\
      = 2^4 + 2^3 + 2^1 + 2^{-1} + 2^{-3} \\
      = 26,625.
    \end{gather}

    \begin{lstlisting}
      >>> 2**4 + 2**3 + 2 + 2**-1 + 2**-3
      26.625
    \end{lstlisting}

  \item $b=10 \to 4$.
    Primeiramente, decompomos $26,625$ em sua parte inteira $I = 26$ e em sua parte fracionária $0,625$. Então, ao fazermos sucessivas divisões de $I$ por $b=4$, obtemos:
    \begin{align}
      I &= 26\\
        &= 6\times 4 + 2\times 4^0\\
        &= (1\times 4 + 2)\times 4 + 2\times 4^0\\
        &= 1\times 4^2 + 2\times 4 + 2\times 4^0\\
        &= (122)_4.
    \end{align}

    \begin{lstlisting}
      I = int(26.625)
      d_int = []
      while (I != 0):
        d_int.insert(0, I % 4)
        I //= 4
      print('(',*d_int,')_4',sep="")
    \end{lstlisting}
    
    Agora, para a parte fracionária, usamos sucessivas multiplicações de $F$ por $b=4$, obtendo:
    \begin{align}
      F &= 0,625\\
        &= 2,5\times 4^{-1} = 2\times 4^{-1} + 0,5\times 4^{-1}\\
        &= 2\times 4^{-1} + 2\times 4^{-1}\times 4^{-1}\\
        &= 2\times 4^{-1} + 2\times 4^{-2}\\
        &= (0,22)_{4}.
    \end{align}

    \begin{lstlisting}
      F = 26.625 % 1
      d_fra = []
      while (F != 0):
        F *= 4
        d_fra.append(int(F))
        F %= 1
      print('(0,',*d_fra,')_4',sep="")
    \end{lstlisting}
  \end{enumerate}

  Por fim, dos passos 1. e 2., temos $(11010,101)_2 = (122,22)_4$.

  \begin{lstlisting}
    >>> print('(',*d_int,',',*d_fra,')_4', sep='')
    (122,22)_4
  \end{lstlisting}
\end{ex}

\subsection{Exercícios Resolvidos}

\begin{exeresol}
  Forneça a representação decimal dos seguintes números:
  \begin{enumerate}[a)]
  \item $(10101)_2$
  \item $(0,4321)_5$
  \item $(23,5)_8$
  \item $(A2A)_{11}$
  \item $(BEBE)_{16}$
  \end{enumerate}
\end{exeresol}
\begin{resol}
  \begin{enumerate}[a)]
  \item $(\stackrel{4}{1}~\stackrel{3}{0}~\stackrel{2}{1}~\stackrel{1}{0}\stackrel{0}{1})_2$

    \begin{lstlisting}
      >>> 0b10101
      21
    \end{lstlisting}

  \item $(\stackrel{0}{0},\stackrel{-1}{~\,4}~\stackrel{-2}{~\,3}~\stackrel{-3}{~\,2}~\stackrel{-4}{~\,1})_5$

    \begin{lstlisting}
      >>> 4*5**-1+3*5**-2+2*5**-3+5**-4
      0.9376000000000001
    \end{lstlisting}
  
  \item $(\stackrel{1}{2}~\stackrel{0}{3},\stackrel{-1}{~\,5})_8$

    \begin{lstlisting}
      >>> 0o235 / 8**1
      19.625
    \end{lstlisting}

  \item $(\stackrel{2}{A}~\stackrel{1}{2}~\stackrel{0}{A})_{11}$

    \begin{lstlisting}
      >>> int('A2A', 11)
      1242
    \end{lstlisting}

  \item $(\stackrel{3}{B}~\stackrel{2}{E}~\stackrel{1}{B}~\stackrel{0}{E})_{16}$

    \begin{lstlisting}
      >>> 0xBEBE
      48830
    \end{lstlisting}
  \end{enumerate}
\end{resol}

\begin{exeresol}
  Forneça a representação na base indicada dos seguintes números decimais:
  \begin{enumerate}[a)]
  \item $203 \to$ base 2
  \item $0,671875 \to$ base 2
  \item $17,25 \to$ base 8
  \item $3245,875 \to$ base 16
  \end{enumerate}
\end{exeresol}
\begin{resol}
  \begin{enumerate}[a)]

  \item $203 \to$ base 2
    Usando o método {\python} \lstinline+bin+, obtemos

    \begin{lstlisting}
      >>> bin(203)
      '0b11001011'
    \end{lstlisting}
    ou seja, $203 = (11001011)_2$.

  \item $0,671875 \to$ base 2.

    Executando o código
    \begin{lstlisting}
      F = 0.671875
      digs = []
      while (F != 0):
        F *= 2
        digs.append(int(F))
        F %= 1
      print('(0,',*digs,')_2',sep="")      
    \end{lstlisting}
    obtemos que $0,671875 = (0,101011)_2$.

  \item $17,25 \to$ base 8

    Temos que
    \begin{align}
      17,25 &= 17 + 0,25\\
            &= 16 + 1 + \frac{2}{8}\\
            &= 2\cdot 8^1 + 1\cdot 8^0 + 2\cdot 8^{-1}\\
            &= (21,2)_8
    \end{align}

  \item $3245,875 \to$ base 16

    Executando o seguinte código
    \begin{lstlisting}
      # base
      b = 16
      # dígitos
      digs = "0123456789ABCDEF"

      # número
      x = 3245.875

      # parte inteira 
      I = int(x)
      di = []
      while (I != 0):
        di.insert(0, I % b)
        I //= b

      # parte fracionária
      F = x % 1
      df = []
      while (F != 0):
        F *= b
        df.append(int(F))
        F %= 1

      print('(',*[digs[d] for d in di],\
            ',',*[digs[d] for d in df],f')_{b}',sep="")      
    \end{lstlisting}
    obtemos $3245,875 = (CAD,E)_{16}$.      

  \end{enumerate}
\end{resol}

\begin{exeresol}
  Na base indicada, forneça a representação dos seguintes números:
  \begin{enumerate}[a)]
  \item $(1101)_2 \to$ base 8
  \item $(1011,0101)_2 \to$ base 8
  \end{enumerate}
\end{exeresol}
\begin{resol}
  \begin{enumerate}[a)]
  \item $(1101)_2 \to$ base 8

    \begin{lstlisting}
      >>> oct(0b1101)
      '0o15'
    \end{lstlisting}
    Ou seja, $(1101)_2 = (15)_8$.
    
  \item $(1011,0101)_2 \to$ base 8

    Primeiro, convertemos $(1011,0101)_2$ para decimal (base 10).
    \begin{lstlisting}
      >>> 0b10110101 / 2**4
      11.3125    
    \end{lstlisting}
    
    Logo, convertemos para a base octal (base 8) com o seguinte código:

    \begin{lstlisting}
      # base
      b = 8

      # número
      x = 11.3125

      # parte inteira 
      I = int(x)
      di = []
      while (I != 0):
        di.insert(0, I % b)
        I //= b

      # parte fracionária
      F = x % 1
      df = []
      while (F != 0):
        F *= b
        df.append(int(F))
        F %= 1

      print('(',*di,',',*df,f')_{b}',sep="")      
    \end{lstlisting}

    Com este último, obtemos $(1011,0101)_2 = 11,3125 = (13,24)_8$
  \end{enumerate}  
\end{resol}

\subsection{Exercícios}

\begin{exer}
  Obtenha a representação decimal dos seguinte números:
  \begin{enumerate}[a)]
  \item $(101101,00101)_2$
  \item $(23,1)_4$
  \item $(DAAD)_{16}$
  \item $(33,11)_8$
  \item $(51)_3$
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~$45,15625$; b)~$11,25$; c)~$55981$; d)~$27,140625$; e)~$1220$
\end{resp}

\begin{exer}
  Obtenha a representação dos seguintes números decimais na base indicada:
  \begin{enumerate}[a)]
  \item $10$ na base 2.
  \item $45,5$ na base 2.
  \item $41$ na base octal.
  \item $66,31640625$ na base hexadecimal.
  \item $0,\overline{3}$ na base 3.
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~$(1010)_2$; b)~$(101101,1)_2$; c)~$(51)_8$; d) $(42,51)_{16}$; e) $(0,1)_3$
\end{resp}

\begin{exer}
  Obtenha a representação dos seguintes números na base indicada:
  \begin{enumerate}[a)]
  \item $(101101,00101)_2$ na base 4.
  \item $(23,1)_4$ na base 2.
  \item $(2001)_{16}$ na base 8.
  \end{enumerate}
\end{exer}
\begin{resp}
   a)~$(231,022)_4$; b)~$(1011,01)_2$; c)~$(20001)_8$
\end{resp}

\begin{exer}
  Obtenha a representação dos seguintes números na base indicada:
  \begin{enumerate}[a)]
  \item $(0,1)_3$ na base decimal.
  \item $(0,\overline{1})_3$ na base decimal.
  \item $0,\overline{3}$ na base octal.
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~$0,\overline{3}$; b)~$1.5$; c)~$(0,\overline{25})_8$;
\end{resp}

\begin{exer}
  Obtenha a representação dos seguintes números na base indicada:
  \begin{enumerate}[a)]
  \item $0,3$ na base 4.
  \item $0,3$ na base 9.
  \item $(A8)_{16}$ na base 5.
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~$(0,1\overline{03})_4$; b)~$(0,\overline{27})$; c)~$(2,2)_5$
\end{resp}

\section{Representação de Números em Máquina}\label{cap_artm_sec_repummaq}

\begin{flushright}
  [YouTube] | [Vídeo] | [Áudio] | \href{https://phkonzen.github.io/notas/contato.html}{[Contatar]}
\end{flushright}

Usualmente, números são manipulados em máquina através de suas representações em registros com $n$-{\it bits}. Ao longo desta seção, vamos usar a seguinte notação
\begin{equation}
  [b_1 ~ b_2 ~ b_3 ~ \cdots ~ b_n],
\end{equation}
para representar um registro de $n$-{\it bits} $b_i\in\{0, 1\}$, $i=1, 2, \dotsc, n$.

Na sequência, fazemos uma breve discussão sobre as formas comumente usadas para a manipulação de números em computadores.

\subsection{Números inteiros}

O sistema de complemento de 2 é utilizado em computadores para a manipulação de números inteiros. Nesta representação, um registro de $n$~{\it bits}
\begin{equation}
  [d_1 ~ d_2 ~ d_3 ~ \cdots ~ d_n],
\end{equation}
representa o número inteiro
\begin{equation}
  x = (d_{n-1}~\ldots~d_2~d_1)_2 - d_n2^{n-1}.
\end{equation}

\begin{ex}
  O registro de 8~{\it bits}\footnote{8~{\it bits} = 1~{\it byte} [B].}
  \begin{equation}
    [1 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0]
  \end{equation}
  representa o número
  \begin{align}
    x &= -d_8\cdot 2^{8-1} + (d_7~d_6~\ldots~d_1)_2\\
      &= -0\cdots 2^{7} + (\stackrel{6}{0}~\stackrel{5}{0}~\stackrel{4}{0}~\stackrel{3}{0}~\stackrel{2}{0}~\stackrel{1}{1}~\stackrel{0}{1})_2\\
      &= 2^1 + 2^0 = 3.
  \end{align}
  
  Podemos implementar um conversor de registro para número inteiro como segue
  \begin{lstlisting}[caption=packbits8.py, label=cod:packbits8]
    def packBitsInt8(dd):
    x = -dd[7] * 2**7
    for i, d in enumerate(dd[:7]):
        x += d * 2**(i)
    return x
  \end{lstlisting}
  Esta função, converte uma lista de {\it bits} (registro) no inteiro corresponde ao sistema de complemento 2.
  \begin{lstlisting}
    >>> packBitsInt8([1,1,0,0,0,0,0,0])
    3
  \end{lstlisting}
\end{ex}

Na representação de complemento de 2 com $n$~{\it bits}, o menor e o maior números inteiros são obtidos com os registros
\begin{gather}
  -2^{n-1} \sim [0 ~ 0 ~ 0 ~ 0 ~ \cdots ~ 1],\\
  2^{n-1}-1 \sim [1 ~ 1 ~ 1 ~ \cdots ~ 1 ~ 0],
\end{gather}
respectivamente. Já o zero é obtido com o registro
\begin{equation}
  0 \sim [0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0].
\end{equation}

\begin{ex}
  Com um registro de $8$-{\it bits}, temos que o menor e o maior números inteiros que podem ser representados são
  \begin{gather}
    [0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 1] \\
    \sim -2^{7} + (0000000)_2 = -128,
  \end{gather}
  e
  \begin{gather}
    [1 ~ 1 ~ 1 ~ 1 ~ 1 ~ 1 ~ 1 ~ 0] \\
    \sim -0\cdot 2^7 + (1111111)_2 = 127,
  \end{gather}
  respectivamente.

  Usando o Código \ref{cod:packbits8}, temos
  \begin{lstlisting}
    >>> packBitsInt8([0,0,0,0,0,0,0,1])
    -128
    >>> packBitsInt8([1,1,1,1,1,1,1,0])
    127
    >>> packBitsInt8([0,0,0,0,0,0,0,0])
    0
  \end{lstlisting}
\end{ex}

\begin{obs}
  No {\numpy}, o \lstinline+dtype=numpy.int8+ corresponde a inteiros de 8~{\it bits}.
  \begin{lstlisting}
    >>> import numpy as np
    >>> np.array([-127, 0, 3, 128, 129], dtype=np.int8)
    array([-127,    0,    3, -128, -127], dtype=int8)
  \end{lstlisting}
  Consulte a lista de tipos básicos do {\numpy} em \href{https://numpy.org/doc/stable/user/basics.types.html}{NumPy:Data types}.
\end{obs}

A adição de números inteiros na representação de complemento de 2 pode ser feita de maneira simples. Por exemplo, consideremos a soma $3 + 9$ usando registros de 8 {\it bits}. Temos
\begin{align}
  3 &\sim [1 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0]\\
  9 &\sim [1 ~ 0 ~ 0 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0] ~ + \\
  - & -------- \\
 12 &\sim [0 ~ 0 ~ 1 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0]
\end{align}

No sistema de complemento de 2, a representação de um número negativo $-x$ pode ser obtida da representação de $x$, invertendo seus {\it bits} e somando 1. Por exemplo, a representação de $-3$ pode ser obtida da representação de $3$, como segue
\begin{equation}
  3 \sim [1 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0].
\end{equation}
Invertendo seus {\it bits} e somando 1, obtemos
\begin{equation}
  -3 \sim [1 ~ 0 ~ 1 ~ 1 ~ 1 ~ 1 ~ 1 ~ 1].
\end{equation}

A subtração de números inteiros usando a representação de complemento de 2 fica, então, tanto simples quanto a adição. Por exemplo:
\begin{align}
  3 &\sim [1 ~ 1 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0 ~ 0]\\
 -9 &\sim [1 ~ 1 ~ 1 ~ 0 ~ 1 ~ 1 ~ 1 ~ 1] ~ + \\
  - & -------- \\
 -6 &\sim [0 ~ 1 ~ 0 ~ 1 ~ 1 ~ 1 ~ 1 ~ 1]
\end{align}

\subsection{Ponto flutuante}

A manipulação de números decimais em computadores é comumente realizada usando a representação de ponto flutuante de 64~{\it bits}\footnote{Padrão IEEE 754.}. Nesta, um dado registro de 64~{\it bits}
\begin{equation}
  [s ~ | ~ c_{10} ~ c_9 ~ \ldots ~ c_{0} ~ | ~ m_1 ~ m_2 ~ \ldots ~ m_{52}]
\end{equation}
representa o número
\begin{equation}
  x = (-1)^s M\cdot 2^{c - 1023},
\end{equation}
onde $M$ é chamada de mantissa e $c$ da característica, as quais são definidas por
\begin{align}
  M &:= (1,m_1m_2m_3\ldots m_{52})_2,\\
  c &:= (c_{10}\ldots c_2c_1c_0)_2.
\end{align}

\begin{ex}
  Por exemplo, na representação em ponto flutuante de 64~{\it bits}, temos que o registro
  \begin{equation}\label{eq:regfloat64}
    [1 ~ | ~ 1 ~ 0 ~ \ldots ~ 0 ~ 0 ~ | ~ 1 ~ 0 ~ 1 ~ 0 ~ 0 ~ \ldots ~ 0]
  \end{equation}
  representa o número $-3,25$.

  A seguinte função faz a conversão  uma lista de 64~{\it bits} no número decimal corresponde ao sistema de ponto flutuante de 64~{\it bits}.
  \begin{lstlisting}[caption=packBitsDouble.py, label=cod:packBitsDouble]
    def packBitsDouble(ld):
    s = ld[0]
    c = 0
    for i, d in enumerate(ld[1:12]):
        c += d * 2**(10-i)
    m = 1.
    for i, d in enumerate(ld[12:]):
        m += d * 2**(-(i+1))
    x = m * 2**(c - 1023)
    return -x if s else x
  \end{lstlisting}
  Por exemplo, usando-a para o registro acima, obtemos
  \begin{lstlisting}
    >>> ld[0]=1; ld[1]=1; ld[12]=1; ld[13]=1
    >>> packBitsDouble(ld)
    -3.5
  \end{lstlisting}
\end{ex}

\subsection{Erro de arredondamento}

Dado um número real $x$, sua representação $fl(x)$ em ponto flutuante é o registro que representa o número mais próximo de $x$. Este procedimento é chamado de arredondamento por proximidade.

A seguinte função obtém a representação em ponto flutuante de 64~{\it bits} de um dado número $x$\footnote{Esta função não é precisa e pode fornecer registros errados devido a erros de arredondamento. Uma alternativa melhor é apresentada na Observação \ref{obs:unpackBitsDouble}.}.
\begin{lstlisting}[caption=unpackBitsDouble.py, label=cod:unpackBitsDouble]
  import numpy as np

  def unpackBitsDouble(x):
    ld = 64*[0]
    if ( x == 0):
        return ld
    elif (x < 0):
        ld [0] = 1
    x = np.fabs(x)
    c = int(np.log2(x) + 1023)
    m = x/2**(c - 1023)
    for i in range(11):
        ld [11 - i] = c % 2
        c //= 2
    m -= 1
    for i in range(52):
        m *= 2
        ld [12+ i] = int(m)
        m %= 1
    return ld
  \end{lstlisting}

Por exemplo, $x = 1,1$ é representado pelo registro
\begin{lstlisting}
  >>> ld = unpackBitsDouble(1.1)
  >>> ld
  [0, 0, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 0, 0, 0, 1,
   1, 0, 0, 1, 1, 0, 0, 1,
   1, 0, 0, 1, 1, 0, 0, 1,
   1, 0, 0, 1, 1, 0, 0, 1,
   1, 0, 0, 1, 1, 0, 0, 1,
   1, 0, 0, 1, 1, 0, 0, 1,
   1, 0, 0, 1, 1, 0, 1, 0]
\end{lstlisting}
que corresponde ao número
\begin{lstlisting}
  >>> flx = packBitsDouble(ld)
  >>> print(f'{flx:1.51f}')
  1.10000000000000008881784197
  0012523233890533447265625
\end{lstlisting}
O erro de arredondamento é $|x - fl(x)| \approx 8,9\times 10^{-17}$.

\begin{obs}\label{obs:unpackBitsDouble}
  O seguinte código é uma solução mais pythonica para obter-se o registro em ponto flutuante de 64~{\it bits} de $x = 1,1$.
  \begin{lstlisting}
    >>> ''.join(f'{c:08b}' for c in struct.pack('!d', 1.1))
    '0011111111110001
    1001100110011001
    1001100110011001
    1001100110011010'
  \end{lstlisting}
  Recomendamos consultar \cite{Lemire2021a} para mais informações sobre a conversão eficiente de números decimais em pontos flutuantes.
\end{obs}

Observemos que o erro de arredondamento varia conforme o número dado, podendo ser zero no caso de $x = fl(x)$. Comumente, utiliza-se o \emph{épsilon de máquina}\index{épsilon de máquina} como uma aproximação desse erro. O épsilon de máquina é definido como a distância entre o número 1 e seu primeiro sucessor em ponto flutuante. Temos
\begin{lstlisting}
  >>> ld = unpackBitsDouble(1)
  >>> ld
  [0, 0, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0]
  >>> ld[63] = 1
  >>> x = packBitsDouble(ld)
  >>> x-1
  2.220446049250313e-16
\end{lstlisting}
Ou seja, o épsilon de máquina é
\begin{equation}
  \mathrm{eps} := 2^{-52} \approx 2,22\times 10^{-16}.
\end{equation}

\begin{obs}
  O método \href{https://numpy.org/doc/stable/reference/generated/numpy.finfo.html}{\lstinline{numpy.finfo}} pode ser usado para obtermos várias informações sobre o sistema de números em ponto flutuante. Por exemplo, temos
  \begin{lstlisting}
    >>> import numpy as np
    >>> finfo = np.finfo(np.double)
    >>> finfo.eps
    2.220446049250313e-16
    >>> finfo.min
    -1.7976931348623157e+308
    >>> finfo.max
    1.7976931348623157e+308
  \end{lstlisting}
\end{obs}

A aritmética em ponto flutuante requer arredondamentos sucessivos de números. Por exemplo, a computação da soma de dois números dados $x$ e $y$ é feita a partir de suas representações em ponto flutuante $fl(x)$ e $fl(y)$. Então, computa-se $z = fl(x)+fl(y)$ e o resultado é $fl(z)$. Observe, inclusive que $fl(x+y)$ pode ser diferente de $fl(fl(x)+fl(y))$. Por exemplo
\begin{lstlisting}
  >>> 0.1 + 0.2 == 0.3
  False
\end{lstlisting}

\subsection{Exercícios Resolvidos}

\begin{exeresol}
  No sistema de complemento 2 de 8~{\it bits}, forneça o registro que representa os seguintes números inteiros:
  \begin{enumerate}[a)]
  \item 1
  \item -1
  \item 15
  \item -15
  \end{enumerate}
\end{exeresol}
\begin{resol}
  A seguinte função, obtém o registro de complemento 2 de 8-{\it bits} de um dado número inteiro x.
  \begin{lstlisting}
    def unpackBitsInt8(x):
    ld = 8*[0]
    if (x < 0):
        ld[7] = 1
        x += 2**(7)
    for i in range(7):
        ld[i] = x % 2
        x //= 2
    return ld
  \end{lstlisting}
  Usando-a, obtemos os seguintes resultados:
  \begin{lstlisting}
    >>> # a) 1
    >>> unpackBitsInt8(1)
    [1, 0, 0, 0, 0, 0, 0, 0]
    >>> unpackBitsInt8(-1)
    [1, 1, 1, 1, 1, 1, 1, 1]
    >>> # c) 15
    >>> unpackBitsInt8(15)
    [1, 1, 1, 1, 0, 0, 0, 0]
    >>> unpackBitsInt8(-15)
    [1, 0, 0, 0, 1, 1, 1, 1]
  \end{lstlisting}
\end{resol}

\begin{exeresol}
  Qual é o número decimal positivo mais próximo de zero que pode ser representado como um ponto flutuante de 64-{\it bits}. Também, forneça seu registro.
\end{exeresol}
\begin{resol}
  Um registro em ponto flutuante de 64-{\it bits} tem a forma
  \begin{equation}
    [s ~ | ~ c_{10} ~ c_9 ~ \ldots ~ c_{0} ~ | ~ m_1 ~ m_2 ~ \ldots ~ m_{52}]
  \end{equation}
  e representa o número
  \begin{equation}
    x = (-1)^s M\cdot 2^{c - 1023},
  \end{equation}
  onde $M$ é chamada de mantissa e $c$ da característica, as quais são definidas por
  \begin{align}
    M &:= (1,m_1m_2m_3\ldots m_{52})_2,\\
    c &:= (c_{10}\ldots c_2c_1c_0)_2.
  \end{align}
  Tendo em vista que o registro nulo é reservado para o número decimal zero, temos que o número positivo mais próximo de zero é obtido com sinal $s=0$, a mantissa $M=1$ e a característica $c=1$, no que obtemos o decimal
  \begin{align}
    x &= 2^{-1022}\\
      &\approx 2.2250738585072014e-308
  \end{align}
  Seu registro é
  \begin{equation}
    [0 ~ | ~ 0 ~ 0 ~ \ldots ~ 1 ~ | ~ 0 ~ 0 ~ \ldots ~ 0]
  \end{equation}

  O resultado pode ser verificado com os seguintes comandos:
  \begin{lstlisting}
    >>> import numpy as np
    >>> import struct
    >>> x = np.finfo(np.double).tiny; x
    2.2250738585072014e-308
    >>> ''.join(f'{c:08b}' \
    ... for c in struct.pack('!d', x))
    '0000000000010000
    0000000000000000
    0000000000000000
    0000000000000000'
  \end{lstlisting}
\end{resol}

\begin{exeresol}
  Em aplicações que não necessitam de muita precisão, a representação de números decimais no sistema de ponto flutuante de 32~{\it bits} é mais eficiente (no sentido de velocidade de processamento computacional). Neste sistema, um registro de 32-{\it bits}
  \begin{equation}
    [s ~ | ~ c_7 ~ c_6 ~ \ldots ~ c_0 ~ | ~ m_1 ~ m_2 ~ \ldots ~ m_{23}]
  \end{equation}
  representa o número
  \begin{equation}
    x = (-1)^s\cdot M\cdot 2^{c-127}
  \end{equation}
  onde,
  \begin{gather}
    M = (1,m_1m_2\ldots m_{23})_2\\
    c = (c_7c_6\ldots c_0)_2
  \end{gather}
  \begin{enumerate}[a)]
  \item Forneça o registro do ponto flutuante de 32-{\it bits} que representa o número $42,5$.
  \item Qual é o sucessor em ponto flutuante de 32-{\it bits} do número decimal 1. Forneça, também, o épsilon de máquina deste sistema.
  \end{enumerate}
\end{exeresol}
\begin{resol}
  \begin{enumerate}[a)]
  \item O registro do ponto flutuante de 32-{\it bits} que representa o número $42,5$ pode ser computado com o seguinte código:
    \begin{lstlisting}
      x = 42.5
      ld = 32*[0]
      c = int(np.log2(x) + 127)
      m = x/2**(c-127)
      for i in range(8):
        ld[8-i] = c % 2
        c //= 2
      m -= 1
      for i in range(23):
        m *= 2
        ld[9+i] = int(m)
        m %= 1
    \end{lstlisting}
    \begin{lstlisting}
      >>> ld
      [0, 1, 0, 0, 0, 0, 1, 0,
      0, 0, 1, 0, 1, 0, 1, 0,
      0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0]
    \end{lstlisting}

    Alternativamente, pode-se obter o registro como segue:
    \begin{lstlisting}
      >>> ''.join(f'{c:08b}' \
      ... for c in struct.pack('!f', 42.5))
      '0100001000101010
      0000000000000000'
    \end{lstlisting}

  \item No sistema de ponto flutuante de 32-{\it bits}, o sucessor de 1 tem o registro
    \begin{equation}
      [0 ~ | ~ 0 ~ 1 ~ 1 ~ \ldots ~ 1 ~ | ~ 0 ~ 0 ~ \ldots ~ 0 ~ 1]
    \end{equation}
    donde, sua mantissa é $m = 1 + 2^{-23}$, característica $c = 127$ e corresponde ao número decimal
    \begin{gather}
      x = (-1)^0\cdot (1 + 2^{-23})\cdot 2^{127-127}\\
      x = 1 + 2^{-23}
    \end{gather}
    Portanto, o épsilon de máquina neste sistema é
    \begin{align}
      \mathrm{eps} &= x - 1\\
                   &= 2^{-23}
    \end{align}

    \begin{lstlisting}
      >>> np.float32(2**-23)
      1.1920929e-07
    \end{lstlisting}
  \end{enumerate}
\end{resol}

\emconstrucao

\subsection{Exercício}

\begin{exer}
  Considerando a representação de complemento de 2 de números inteiros, obtenha os registros de $8$-{\it bits} dos seguintes números:
  \begin{enumerate}[a)]
  \item $17$
  \item $-17$
  \item $32$
  \item $-32$
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~[10001000]; b)~[11110111]\\
  c)~[00000100]; d)~[00000111]
\end{resp}

\begin{exer}
  Considerando a representação de complemento de 2 de números inteiros, obtenha os registros de $16$-{\it bits} dos seguintes números:
  \begin{enumerate}[a)]
  \item $1024$
  \item $-1024$
  \end{enumerate}
\end{exer}
\begin{resp}
    a)~[0000000000100000]; \\
    b)~[0000000000111111];
\end{resp}

\begin{exer}
  Considerando a representação de complemento de 2 de números inteiros, qual é o maior número que pode ser representado por um registro de $32$-{\it bits} da forma
  \begin{equation}
    [1 ~ 0 ~ b_2 ~ b_3 ~ b_4 ~ \cdots ~ b_{30} ~ 1],
  \end{equation}
onde $b_i \in \{0, 1\}$, $i=2, 3, 4, \cdots, 30$.
\end{exer}
\begin{resp}
  $[10111~\ldots~11] \sim -3$
\end{resp}

\begin{exer}
  Obtenha os registros em ponto flutuante de $64$-{\it bits} dos seguintes números:
  \begin{enumerate}[a)]
  \item $-1,25$
  \item $3$
  \end{enumerate}
\end{exer}
\begin{resp}
    a)~$[1 ~ | ~ 0 ~ 1 ~ 1 ~ \ldots ~ 1 ~ | ~ 1 ~ 0 ~ 1 ~ 0 ~ 0 ~ \ldots ~ 0]$;\\
    b)~$[0 ~ | ~ 1 ~ 0 ~ 0 ~ \ldots ~ 0 ~ | ~ 1 ~ 0 ~ 0 ~ \ldots ~ 0]$
\end{resp}

\begin{exer}
  Assumindo o sistema de ponto flutuante de $32$-{\it bits}, obtenha o registro e o erro de arredondamento na representação dos seguintes números decimais:
  \begin{enumerate}[a)]
  \item $0,1$
  \item $10,1$
  \item $100,1$
  \end{enumerate}
\end{exer}
\begin{resp}
  \begin{enumerate}[a)]
  \item % a)
    \begin{lstlisting}
      [0, 0, 1, 1, 1, 1, 0, 1,
      1, 1, 0, 0, 1, 1, 0, 0,
      1, 1, 0, 0, 1, 1, 0, 0,
      1, 1, 0, 0, 1, 1, 0, 1]
    \end{lstlisting}
    $|0,1 - fl(0,1)| \approx 1,5e^{-9}$
  \item % b)
    \begin{lstlisting}
      [0, 1, 0, 0, 0, 0, 0, 1,
      0, 0, 1, 0, 0, 0, 0, 1,
      1, 0, 0, 1, 1, 0, 0, 1,
      1, 0, 0, 1, 1, 0, 1, 0]
    \end{lstlisting}
    $|10,1 - fl(10,1)| \approx 3,8e^{-7}$
  \item % c)
    \begin{lstlisting}
      [0, 1, 0, 0, 0, 0, 1, 0,
      1, 1, 0, 0, 1, 0, 0, 0,
      0, 0, 1, 1, 0, 0, 1, 1,
      0, 0, 1, 1, 0, 0, 1, 1]
    \end{lstlisting}
    $|100,1 - fl(100,1)| \approx 1,5e^{-6}$
  \end{enumerate}
\end{resp}


\section{Notação Científica e Arredondamento}\label{cap_aritm_sec_notcient}

Enquanto que a manipulação computacional de números decimais é feita usando-se da aritmética em ponto flutuante, a interpretação dos parâmetros dos problemas de interesse e seus resultados é normalmente feita com poucos dígitos. Nesta seção, introduziremos algumas notações que serão utilizadas ao longo deste material.

A \hl{\emph{notação científica}} é a representação de um dado número na forma
\begin{equation}
  \hleq{d_{n}\ldots d_2d_1d_0,d_{-1}d_{-2}d_{-3}\ldots \times 10^{E}},
\end{equation}
onde $d_i$, $i=n, \ldots, 1, 0, -1, \ldots$, são algarismos da base 10. A parte à esquerda do sinal $\times$ é chamada de \hl{\emph{mantissa}} do número e $E$ é chamado de \hl{\emph{expoente}} (ou ordem de grandeza).

\begin{ex}\label{ex:notacao_cientifica}
  O número $31,515$ pode ser representado em notação científica das seguintes formas
  \begin{align}
    31,415\times 10^0 &= 3,1415\times 10^{1} \\
                      &= 314,15\times 10^{-1} \\
                      &= 0,031415\times 10^{3},
  \end{align}
  entre outras tantas possibilidades.

  \hl{Em {\python}, usa-se a letra {\lstinline+e+} para separar a mantissa do expoente} na notação científica. Por exemplo
  \begin{lstlisting}
    >>> # 31.415 X 10^0
    >>> 31.415e0
    31.515
    >>> # 3.1415 X 10^1
    >>> 3.1415e1
    31.515
    >>> # 314.15 X 10^-1
    >>> 314.15e-1
    31.515
    >>> # 0.031415 X 10^3
    >>> 0.031415e3
    31.415
  \end{lstlisting}
\end{ex}

No exemplo anterior (Exemplo~\ref{ex:notacao_cientifica}), podemos observar que a representação em notação científica de um dado número não é única. Para contornar isto, introduzimos a \colorbox{yellow}{\emph{notação científica normalizada}}, a qual tem a forma
\begin{equation}
  \hleq{d_0,d_{-1}d_{-2}d_{-3}\ldots\times 10^{E}},
\end{equation}
com $d_0 \neq 0$\footnote{No caso do número zero, temos $d_0=0$.}.

\begin{ex}
  O número $31,415$ representado em notação científica normalizada é $3,1415\times 10^{1}$.

  Em {\python}, podemos usar o método \href{https://docs.python.org/3.8/library/string.html#formatspec}{\lstinline+format+} para imprimir um número em notação científica normalizada. Por exemplo, temos
  \begin{lstlisting}
    >>> x = 31.415
    >>> print(f"{x:e}")
    3.141500e+01
  \end{lstlisting}
\end{ex}

Como vimos na seção anterior, usamos da aritmética de ponto flutuante nas computações, com a qual os números são representados com muito mais dígitos dos quais costumeiramente estamos interessados na interpretação dos resultados. Isto nos leva de volta a questão do arredondamento.

Dizemos que \hl{um número está representado com $n$ \emph{dígitos significativos}} (na notação científica normalizada) \hl{quando está escrito na forma}
\begin{equation}
  \hleq{d_0,d_{1}d_{2}\ldots d_{n-1}\times 10^{E}},
\end{equation}
com $d_0\neq 0$.

\begin{ex}
  Estudamos as seguintes representações do número $31,415$:
  \begin{enumerate}[a)]
  \item com 5 dígitos significativos
    \begin{lstlisting}
      >>> x = 31.415
      >>> print(f"{x:.4e}")
      3.1415e+01
    \end{lstlisting}
  \item com 6 dígitos significativos
    \begin{lstlisting}
      >>> print(f"{x:.5e}")
      3.14150e+01
    \end{lstlisting}
  \item com 4 dígitos significativos
    \begin{lstlisting}
      >>> print(f"{x:.3e}")
      3.142e+01
    \end{lstlisting}
    Neste último caso, fez-se necessário arredondar o número.
  \end{enumerate}
\end{ex}

\subsection{Arredondamento}

Observamos que pode ocorrer a necessidade de se arredondar um número para obter sua representação com um número finito de dígitos significativos. Por exemplo, para representarmos o número $x=3,1415\times 10^1$ com 3 dígitos significativos, precisamos determinar de que forma vamos considerar a contribuição de seus demais dígitos a direita. Isto, por sua vez, é determinado pelo tipo de arredondamento que iremos utilizar.

O tipo de arredondamento mais comumente utilizado é o chamado \hl{\emph{arredondamento por proximidade com desempate par}}. Neste, \hl{a representação escolhida é aquela mais próxima do número dado}. Por exemplo, a representação de 
\begin{equation}
  x=3,1415\times 10^1
\end{equation}
com três dígitos significativos é 
\begin{equation}
  x=3,14\times 10^{1}. 
\end{equation}
Agora, sua representação com apenas dois dígitos significativos é
\begin{equation}
  x=3,1\times 10^{1}.
\end{equation}
\hl{No caso de empate}, usa-se a seguinte regra: \hl{1) se o último dígito significativo ser par, este é mantido; 2) se o último dígito significativo ser ímpar, este é acrescido de uma unidade}. Por exemplo, no caso do número $x=3,1415\times 10^1$, sua representação com 4 dígitos significativos é
\begin{equation}
  x = 3,142\times 10^1.
\end{equation}

\begin{obs}\label{obs:arredondamento_ieee754}
  \hl{O arredondamento por proximidade com desempate par é o padrão do IEEE 754}\footnote{Para mais detalhes, consulte \href{https://en.wikipedia.org/wiki/IEEE\_754\#Rounding\_rules}{IEEE 754: Wikipedia}.}. No entanto, devemos lembrar que a maioria dos números decimais não tem representação exata no sistema de ponto flutuante. Por exemplo,
  \begin{lstlisting}
    >>> x = 31.415
    >>> print(f'{x:.3e}')
    3.141e+01
  \end{lstlisting}
  Embora o arrendamento não seja o esperado, o que ocorre é que $x = 31,415$ não tem representação exata em ponto flutuante, de fato
  \begin{lstlisting}
    >>> print(f'{x:.25e}')
    3.1414999999999999147348717e+01
  \end{lstlisting}
\end{obs}

No restante deste material estaremos assumindo a notação científica normalizada com arredondamento por proximidade com desempate par.

\subsection{Exercícios Resolvidos}

\begin{exeresol}
  Faça o cálculo exato e a computação de
  \begin{equation}
    \frac{0,33411\times 10^2 - 271,28\times 10^{-1}}{2000\times 10^{-3}}
  \end{equation}
  Forneça os resultados com 4 dígitos significados.
\end{exeresol}
\begin{resol}
  \begin{itemize}
  \item Por cálculo exato.
    \begin{gather}
      \frac{0,33411\times 10^2 - 271,28\times 10^{-1}}{2000\times 10^{-3}}\\
      = \frac{334,11\times 10^{-1} - 271,28\times 10^{-1}}{2\times 10^0}\\
      = \frac{63,83\times 10^{-1}}{2}\\
      = 31,415\times 10^{-1}
    \end{gather}
    Arredondando o resultado para 4 dígitos significativos, obtemos $3,142$.
  \item Por computação.
    \begin{lstlisting}
      >>> x = (0.33411e2 - 271.28e-1)/2000e-3
      >>> x
      3.1415000000000006
      >>> print(f'{x:.3e}')
      3.142e+00
    \end{lstlisting}
  \end{itemize}
\end{resol}

\begin{exeresol}
  Obtenha os arredondamentos dos seguintes números decimais para quantidade de dígitos significativos indicada em cada caso. Então, compare com a computada em ponto flutuante.
  \begin{enumerate}[a)]
  \item $2,7128$ com 4 dígitos significativos.
  \item $2,7128$ com 2 dígitos significativos.
  \item $1,9910$ com 3 dígitos significativos.
  \item $1,9910$ com 2 dígitos significativos.
  \item $5,5555$ com 4 dígitos significativos.
  \item $5,6555$ com 4 dígitos significativos.
  \end{enumerate}
\end{exeresol}
\begin{resol}
  \begin{enumerate}[a)]
  \item $2,7128$ com 4 dígitos significativos = $2,713$
    \begin{lstlisting}
      >>> f'{2.7128:.3e}'
      '2.713e+00'
    \end{lstlisting}
  \item $2,7128$ com 2 dígitos significativos = $2,7$
    \begin{lstlisting}
      >>> f'{2.7128:.1e}'
      '2.7e+00'
    \end{lstlisting}
  \item $1,9910$ com 3 dígitos significativos = $1,99$
    \begin{lstlisting}
      >>> f'{1.9910:.2e}'
      '1.99e+00'
    \end{lstlisting}
  \item $1,9910$ com 2 dígitos significativos = $2,0$
    
    \begin{lstlisting}
      >>> f'{1.9910:.1e}'
      '2.0e+00'
    \end{lstlisting}
        
  \item $5,5555$ com 4 dígitos significativos = $5,556$
    
    \begin{lstlisting}
      >>> f'{5.5555:.3e}'
      '5.556e+00'
    \end{lstlisting}
        
  \item $5,6555$ com 4 dígitos significativos = $5,556$
    
    \begin{lstlisting}
      >>> f'{5.6555:.3e}'
      '5.655e+00'
    \end{lstlisting}
        
  \end{enumerate}
\end{resol}

\subsection{Exercícios}

\begin{exer}
  Obtenha a representação dos seguintes números decimais em notação científica normalizada com a quantidade de dígitos indicada em cada caso. Então, compare com o arredondamento computado em ponto flutuante. Caso haja diferença, explique.
  \begin{enumerate}[a)]
  \item $\pi$ com 6 dígitos significativos.
  \item $\pi/10$ com 6 dígitos significativos.
  \item $\sqrt{2}/\sqrt{3}$ com 7 dígitos significativos.
  \end{enumerate}
\end{exer}
\begin{resp}
  a) $3,14159\times 10^0$, \lstinline+3.14159e+00+; b) $3,14159\times 10^{-1}$, \lstinline+3.14159e-01+; c) $8,164922\times 10^{-1}$, \lstinline+8.164966e-01+
\end{resp}

\begin{exer}
  Compute a seguinte expressão
  \begin{equation}
    \frac{\sqrt{\pi} - \ln(0,9)}{75\cos\left(\frac{\pi}{4}\right)}.
  \end{equation}
  Forneça a resposta com 7 dígitos significativos.
\end{exer}
\begin{resp}
  $3,540841\times 10^{-1}$
\end{resp}

\begin{exer}
  Forneça o arredondamento dos seguintes números decimais para 2 dígitos significativos. Então, compare com o arrendamento computado em ponto flutuante. Caso haja diferença, explique.
  \begin{enumerate}[a)]
  \item $0,625$
  \item $0,615$
  \item $0,635$
  \end{enumerate}
\end{exer}
\begin{resp}
  a) $6,2\times 10^{-1}$, \lstinline+6.2e-01+; b) $6,2\times 10^{-1}$, \lstinline+6.1e-01+; c) $6,4\times 10^{-1}$; \lstinline+6.4e-01+
\end{resp}

\begin{exer}
  Seja $f_s$ a função que recebe número decimal e retorna sua aproximação por arrendamento com 2 dígitos significativos. Calcule
  \begin{enumerate}[a)]
  \item $f_s(2\pi - e)$
  \item $2f_s(\pi) - f_s(e)$
  \item Por que $f_s(2\pi - e) \neq  2f_s(\pi) - f_s(e)$?
  \end{enumerate}
\end{exer}
\begin{resp}
  a) $3,5$; b) $3,6$; c) Operar sobre números arredondados acarreta perda de exatidão.
\end{resp}


\begin{exer}
  Explique o porquê de
  \begin{lstlisting}
    >>> np.sqrt(3)**2 == 3
    False
  \end{lstlisting}
\end{exer}
\begin{resp}
  Dica: $\sqrt{3}$ não tem representação exata em ponto flutuante.
\end{resp}


\section{Tipos e Medidas de Erros}\label{cap_aritm_sec_erros}

Ao utilizarmos computadores na resolução de problemas matemáticos, acabamos obtendo soluções aproximadas. A diferença entre a solução exata e a solução aproximada computada é chamada de erro. O erro é comumente classificado nas seguintes duas categorias:
\begin{itemize}
\item \hl{\emph{Erro de Arredondamento}}

  Este é o erro que ocorre na representação aproximada de números na máquina.
  
\item \hl{\emph{Erro de Truncamento}}

  Este é o erro que ocorre na interrupção (truncamento) de um procedimento com infinitos passos.
\end{itemize}

\begin{ex}\normalfont{(\hl{Erro de Arredondamento}.)}\label{ex:erro_de_arredondamento}
  O erro de arredondamento em aproximar $\pi$ por $3,1415\times 10^0$ é de aproximadamente $9,3\times 10^{-5}$.
  
  \begin{lstlisting}
    >>> import numpy as np
    >>> np.pi - 3.1415e0
    9.265358979293481e-05    
  \end{lstlisting}
  
\end{ex}

\begin{ex}\normalfont{(\hl{Erro de Truncamento}.)}\label{ex:erro_de_truncamento}
  Consideramos a seguinte série numérica $\sum_{n=0}^\infty 1/n! = e \approx 2,7183\times 10^0$. Ao computarmos esta série no computador, precisamos truncá-la em algum $n$ suficientemente grande. Por exemplo, truncando a série em seu nono termo, temos
  \begin{align}
    \sum_{n=0}^\infty \frac{1}{n!} &\approx \frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + \cdots + \frac{1}{8!} \\
    &\approx 2.71827876984127 =: \tilde{e}.
  \end{align}

  
  \begin{lstlisting}
    import math
    x = 0
    for n in range(9):
      x += 1./math.factorial(n)
    print(math.fabs(math.e - x))
  \end{lstlisting}
  
A diferença $|e - \tilde{e}| \approx 3\times 10^{-6}$ é o erro de truncamento associado.
\end{ex}

Suponhamos, agora, que $x$ seja o valor exato (valor esperado) de uma quantidade de interesse e $\tilde{x}$ o valor computado (aproximação de $x$). Em matemática numérica, utilizamos frequentemente as seguintes medidas de erro:
\begin{itemize}
  \item \hl{\emph{Erro absoluto}}:
    \begin{equation}
      \hleq{\varepsilon_{\text{abs}} := |x - \tilde{x}|}.
    \end{equation}
  \item \hl{\emph{Erro relativo}}:
    \begin{equation}
      \hleq{\varepsilon_{\text{rel}} := \frac{|x - \tilde{x}|}{|x|}\left(\times 100\%\right)}.
    \end{equation}
\end{itemize}

A vantagem do erro relativo é em levar em conta a ordem de grandeza da quantidade $x$.

\begin{ex}\label{ex:medidas_de_erros}
  Estudamos os seguintes casos:
  \begin{enumerate}[a)]
  \item $x=1,0$ e $\tilde{x} = 1,1$:
    \begin{align}
      \varepsilon_{\text{abs}} &= |x - \tilde{x}| \\
                        &= |1,0 - 1,1|\\
                        &= |-0,1|\\
                        &= 1\times 10^{-1}.\\
      \varepsilon_{\text{rel}} &= \frac{|x - \tilde{x}|}{|x|} \\
                        &= \frac{|1,0-1,1|}{|1,0|}\\
                        &= \frac{|-0,1|}{|1,0|}\\
                        &= 1\times 10^{-1} = 10\%.
    \end{align}
    
    \begin{lstlisting}
      >>> x = 1.0; xa = 1.1
      >>> eabs = abs(x - xa); eabs
      0.10000000000000009
      >>> erel = eabs/abs(x); erel
      0.10000000000000009
    \end{lstlisting}
    
  \item $x=1000,0$ e $\tilde{x} = 1100,0$:
    \begin{align}
      \varepsilon_{\text{abs}} &= |x - \tilde{x}| \\
                        &= |1000,0 - 1100,0|\\
                        &= 1\times 10^2.\\
      \varepsilon_{\text{rel}} &= \frac{|x - \tilde{x}|}{|x|} \\
                        &= \frac{|1000,0 - 1100,0|}{|1000,0|}\\
                        &= \frac{|-100,0|}{|1000,0|}\\
                        &= 1\times 10^{-1} = 10\%.
    \end{align}
    
    \begin{lstlisting}
      >>> x = 1000.0; xa = 1100.0
      >>> eabs = abs(x - xa); eabs
      100.0
      >>> erel = eabs/abs(x); erel
      0.1
    \end{lstlisting}
    
  \end{enumerate}
\end{ex}

Outra \hl{medida de erro} comumente empregada é o \hl{\emph{número de dígitos significativos corretos}}. Dizemos que $\tilde{x}$ aproxima $x$ com $n$ dígitos significativos corretos, quando
\begin{equation}
  \hleq{\underbrace{\frac{|x - \tilde{x}|}{|x|}}_{\varepsilon_{\text{rel}}} < 5\times 10^{-n}}.
\end{equation}
Isso significa que ao arredondarmos $x$ e $\tilde{x}$ ambos com $n$ dígitos, obtemos o mesmo resultado.

\begin{ex}\label{ex:numdigsigcorr}
  Estudamos os seguintes casos:
  \begin{itemize}
  \item $x=2$ e $\tilde{x} = 2,4$
    \begin{equation}
      \varepsilon_{\text{rel}} = 0,2 < 5\times 10^{-1}
    \end{equation}
    Temos que $\tilde{x} = 2,4$ aproxima $x = 2$ com um dígito significativo correto. Note que ambos são iguais quando arredondamentos para um dígito.
  \item $x=2$ e $\tilde{x} = 2,5$
    \begin{equation}
      \frac{|x - \tilde{x}|}{|x|} = 0,25 < 5\times 10^{-1}
    \end{equation}
    Temos que $\tilde{x}=2,5$ é uma aproximação com $1$ dígito significativo correto de $x=2$. Note que ambos são iguais quando arredondamentos para um dígito.
  \item $x=1$ e $\tilde{x} = 1,5$:
    \begin{equation}
      \frac{|x - \tilde{x}|}{|x|} = 0,5 < 5\times 10^{0},
    \end{equation}
    Temos que $\tilde{x}=1,5$ é uma aproximação com zero dígito significativo correto de $x=1$. Note que ao arredondarmos\footnote{Assumindo o arredondamento por proximidade com desempate par.} $\tilde{x}$ para um dígito, obtemos $\tilde{x}\approx 2$, enquanto que $x=1$.
  \end{itemize}
\end{ex}

\subsection{Propagação de Erros}

Nesta seção, vamos introduzir uma \hl{estimativa para a propagação de erros (de arredondamento) na computação de um problema}. Para tando, vamos considerar o caso de se calcular o valor de uma dada função $f$ em um dado ponto $x$, i.e. queremos calcular $y$ com
\begin{equation}\label{eq:properros_aux1}
  y = f(x).
\end{equation}
Agora, assumindo que $x$ seja conhecido com um erro $\varepsilon(x)$, este se propaga no cálculo da $f$, levando a um erro $\varepsilon(y)$ no valor calculado de $y$. Ou seja, temos
\begin{equation}\label{eq:properros_aux2}
  \hleq{y + \varepsilon(y) = f(x+\varepsilon(x))}.
\end{equation}
Denotamos $\varepsilon_{\text{abs}}(x) = |\varepsilon(x)|$ o erro absoluto associado a $x$ e $\varepsilon_{\text{abs}}(y) = |\varepsilon(y)|$ o erro absoluto associado a $y$.

Nosso objetivo é estimar $\varepsilon_{\text{abs}}(y)$ com base em $\varepsilon_{\text{abs}}(x)$. Para tanto, tomamos a aproximação de $f(x+\varepsilon(x))$ dada pelo polinômio de Taylor de grau $1$ de $f$ em torno de $x$, i.e.
\begin{equation}
  f(x+\varepsilon(x)) = f(x) + f'(x)\varepsilon(x) + O\left(\varepsilon^2(x)\right).
\end{equation}
Então, de \eqref{eq:properros_aux1} e \eqref{eq:properros_aux2}, temos
\begin{equation}
  \varepsilon(y) = f'(x)\varepsilon(x) + O(\varepsilon^2(x)).
\end{equation}
Daí, passando ao valor absoluto e usando a desigualdade triangular, obtemos
\begin{align}
  \varepsilon_{\text{abs}}(y) &= \left|f'(x)\varepsilon(x) + O(\varepsilon^2(x))\right|\\
                              &\leq |f'(x)|\varepsilon_{\text{abs}}(x) + O\left(\varepsilon_{\text{abs}}^2(x)\right).
\end{align}
Deste resultado, obtemos a seguinte estimativa de propagação de erro
\begin{equation}\label{eq:estproperro_1}
  \hleq{\varepsilon_{\text{abs}}(y) \approx |f'(x)|\varepsilon_{\text{abs}}(x)}.
\end{equation}

\begin{ex}\label{ex:properro_1}
  Consideramos o problema em se calcular
  \begin{equation}
    y = f(x) = x^2\sen(x)
  \end{equation}
  com $x=\pi/3 \pm 0,1$. Usando \eqref{eq:estproperro_1} para estimarmos o erro absoluto $\varepsilon_{\text{abs}}(y)$ no cálculo de $y$ com base no erro absoluto $\varepsilon_{\text{abs}}(x)=0,1$, calculamos
  \begin{align}
    \varepsilon_{\text{abs}}(y) &= |f'(x)|\varepsilon_{\text{abs}}(x)\\
             &= |2x\sen(x) + x^2\cos(x)|\varepsilon_{\text{abs}}(x)\\
             &= 2,3621\times 10^{-1}.
  \end{align}

  
  \begin{lstlisting}
    >>> import math
    >>> x = math.pi/3; eabsx = 0.1
    >>> eabsy = math.fabs(2*x*math.sin(x) \
    ... + x**2 * math.cos(x)) * eabsx
    >>> print(f"{eabsy:.4e}")
    2.3621e-01
\end{lstlisting}
  
  
  Com isso, concluímos que um erro em $x$ de tamanho $0,1$ é propagado no cálculo de $f(x)$, causando um erro pelo menos duas vezes maior em $y$. Também, podemos interpretar este resultado do ponto de vista do erro relativo. O erro relativo associado a $x$ é
  \begin{align}
    \varepsilon_{\text{rel}}(x) &= \frac{\varepsilon_{\text{abs}}(x)}{|x|}\\
                                &= \frac{0,1}{\pi/3}\\
                                &= 9,5493\times 10^{-2} \approx 10\%,
  \end{align}
  acarretando um erro relativo em $y$ de
  \begin{align}
    \varepsilon_{\text{rel}}(y) &= \frac{\varepsilon_{\text{abs}}(y)}{|y|}\\
                                &= \frac{\varepsilon_{\text{abs}}(y)}{|f(x)|} \\
                                &= 2,4872\times 10^{-2} \approx 25\%.
  \end{align}

  
  \begin{lstlisting}
    >>> import math
    >>> x = math.pi/3; eabsx = 0.1
    >>> erelx = eabsx/math.fabs(x)
    >>> print(f"{erelx*100: .0f} %")
    10 %
    >>> f = lambda x: x**2 * math.sin(x) 
    >>> df = lambda x: 2*x*math.sin(x) \
    ... + x**2 * math.cos(x)
    >>> eabsy = math.fabs(df(x)) * eabsx
    >>> erely = eabsy/math.fabs(f(x))
    >>> print(f"{erely*100: .0f} %")
    25 %
  \end{lstlisting}
  
\end{ex}

Associada à estimativa \eqref{ex:properro_1}, temos
\begin{align*}
  \varepsilon_{\text{rel}}(y) &= \frac{\varepsilon_{\text{abs}}(y)}{|y|}\\
  &= \frac{|f'(x)|}{|y|}\varepsilon_{\text{abs}}(x)\\
  &= \frac{|x|\cdot |f'(x)|}{|f(x)|}\frac{\varepsilon_{\text{abs}}(x)}{|x|}\\
  &= \left|\frac{xf'(x)}{f(x)}\right|\varepsilon_{\text{rel}}(x).
\end{align*}
Desta última equação, definimos o \hl{\emph{número de condicionamento} de $f$}, denotado por
\begin{equation}
  \hleq{\kappa_f(x) := \left|\frac{xf'(x)}{f(x)}\right|}.
\end{equation}
Observamos que \hl{$\kappa_f(x)$ é a escala com que erros em $x$ são propagados no cálculo de $y = f(x)$}.

\begin{ex}\label{ex:numcond_1}
  O número de condicionamento da função $f(x) = x^2\sen(x)$ no ponto $x=\pi/3$ é calculado por
  \begin{align}
    \kappa_f(x) &= \left|\frac{xf'(x)}{f(x)}\right|\\
                &= \left|\frac{x\left[2x\sen(x)+x^2\cos(x)\right]}{x^2\sen(x)}\right|. 
  \end{align}
  Substituindo $x$ por $\pi/3$, obtemos
  \begin{equation}
    \kappa_f(\pi/3) = 2,6046.
  \end{equation}
  Observamos que o resultado é compatível com os obtidos no Exemplo \ref{ex:properro_1}.
  
  
  \begin{lstlisting}
    >>> import math
    >>> f = lambda x: x**2 * math.sin(x) 
    >>> df = lambda x: 2*x*math.sin(x) \
    ... + x**2 * math.cos(x)
    >>> x = math.pi/3
    >>> kf = math.fabs(x*df(x)/f(x))
    >>> print(f"{kf:.4f}")
    2.6046
  \end{lstlisting}
  
\end{ex}

A estimativa \eqref{eq:estproperro_1} pode ser generalizada para uma função de várias variáveis. No caso de uma função $y = f(x_1,x_2,\dotsc,x_n)$, temos
\begin{equation}\label{eq:estproperro_n}
  \hleq{\varepsilon_{\text{abs}}(y) = \sum_{k=1}^n \left|\frac{\p f}{\p x_k}\right|\varepsilon_{\text{abs}}(x_k)}.
\end{equation}

% estou aqui

\begin{ex}\label{ex:properro_2}
  Consideremos o problema em se calcular
  \begin{equation}
    z = f(x,y) = x^2\sen(x)\cos(y)
  \end{equation}
  com
  \begin{gather}
    x = \frac{\pi}{3} \pm 0,1,\\
    y = \frac{\pi}{4} \pm 0,02.
  \end{gather}
  Usando \eqref{eq:estproperro_n} para estimarmos o erro absoluto $e_{\text{abs}}(z)$ no cálculo de $z$ com base nos erros absolutos $e_{\text{abs}}(x)=0,1$ e $e_{\text{abs}}(y)=0,02$, calculamos
  \begin{align}
    e_{\text{abs}}(z) &= \left|\frac{\p f}{\p x}\right|e_{\text{abs}}(x) + \left|\frac{\p f}{\p y}\right|e_{\text{abs}}(y)\\
                      &= |(2x\sen(x) + x^2\cos(x))\cos(y)|e_{\text{abs}}(x)\\
                      &+ \left|-x^2\sen(x)\sen(y)\right|e_{\text{abs}}(y)\\
                      &= 1,8046\times 10^{-1}.
  \end{align}
  
  
  \begin{lstlisting}
    >>> import math
    >>> x = math.pi/3
    >>> eabsx = 0.1
    >>> y = math.pi/4
    >>> eabsy = 0.02
    >>> eabsz = math.fabs((2*x*math.sin(x) \
    ... + x**2*math.cos(x))*math.cos(y))*eabsx \
    ... + math.fabs(-x**2*math.sin(x)*math.sin(y))*eabsy
    >>> print(f"{eabsz:1.4e}")
    1.8046e-01    
  \end{lstlisting}
  
\end{ex}


\subsection{Cancelamento Catastrófico}

No computador (com aritmética de ponto flutuante de 64-{\it bits}), as operações e funções elementares são computadas, usualmente, com um erro próximo do épsilon de máquina\index{épsilon de máquina} ($\mathrm{eps} \approx 10^{-16}$). Entretanto, em algumas situações estas operações fundamentais acarretam erros maiores, causando uma perda de precisão.

O chamado cancelamento catastrófico ocorre quando computamos a diferença entre dois números próximos. Para ilustrá-lo, considaremos os seguintes números
\begin{align}
  x &= 314150000001549,\\
  y &= 314150000002356.
\end{align}
Assumindo os arredondamentos de $x$ e $y$ com $12$ dígitos significativos, temos
\begin{align}
  \tilde{x} &= 314150000002000,\\
  \tilde{y} &= 314150000002000.
\end{align}
Os erros relativos associados às aproximações de $x$ e $y$ por $\tilde{x}$ e $\tilde{y}$ são
\begin{gather}
  e_{rel}(x) = \frac{|x-\tilde{x}|}{|x|} \approx 10^{-10}\%,\\
  e_{rel}(y) = \frac{|y-\tilde{y}|}{|y|} \approx 10^{-10}\%,
\end{gather}
respectivamente. Agora, temos
\begin{gather}
  y-x = 807,\\
  \tilde{y}-\tilde{x}=0.
\end{gather}
Ou seja, o erro relativo na aproximação de $y-x$ por $\tilde{y}-\tilde{x}$ é
\begin{align}
  e_{rel}(y-x) &= \frac{|(y-x)-(\tilde{y}-\tilde{x})|}{(y-x)}\\
               &= \frac{807}{807} = 100\%!
\end{align}

\begin{ex}\label{ex:cancela_1}
  Na tabela abaixo temos os erros em se computar
  \begin{equation}
    \frac{(1+x^4)-1}{x^4}
  \end{equation}
  para diferentes valores de $x$.
  
  \begin{center}
    \begin{tabular}{l|r}
      $x$     & erro \\\hline
      $1$      & $0$ \\
      $10^{-1}$ & $1,1\times 10^{-13}$\\
      $10^{-2}$ & $6,1\times 10^{-9}$\\
      $10^{-3}$ & $8,9\times 10^{-5}$\\
      $10^{-4}$ & $1,0\times 10^{0}$\\
      $10^{-5}$ & $1,0\times 10^{0}$\\\hline
    \end{tabular}
  \end{center}
  Observamos que, para o valor de $x=0,001$ o erro na computação já é da ordem de $10^{-5}$ e para valores de $x$ menores ou iguais a $0,0001$ o erro é catastrófico. Isto ocorre, pois se $x\leq 10^{-4}$, então $x^4 \leq 10^{-16} < \mathrm{eps}$ e, portanto, $(1+x^4)-1=0$.
\end{ex}

\begin{ex}\label{ex:solpq}
  Uma equação de segundo grau $ax^2 + bx + c = 0$ tem raízes
  \begin{align}
    x_1 &= \frac{-b + \sqrt{b^2 - 4ac}}{2a},\label{cap_aritm_sec_erros:eq:cancela_b}\\
    x_2 &= \frac{-b - \sqrt{b^2 - 4ac}}{2a}.\label{cap_aritm_sec_erros:eq:cancela_bx2}
  \end{align}
Entretanto, no caso de $b$ ser positivo, a fórmula \eqref{cap_aritm_sec_erros:eq:cancela_b} não é adequada para a computação da raiz $x_1$, pois pode ocorrer cancelamento catastrófico. Podemos contornar este problema reescrevendo \eqref{cap_aritm_sec_erros:eq:cancela_b} da seguinte forma
\begin{align}
  x_1 &= \frac{-b + \sqrt{b^2 - 4ac}}{2a}\cdot \frac{-b - \sqrt{b^2 - 4ac}}{-b - \sqrt{b^2 - 4ac}}\\
  &= \frac{b^2 - b^2 + 4ac}{2a(-b-\sqrt{b^2-4ac})}\\
  &= \frac{-2c}{b+\sqrt{b^2-4ac}}\label{cap_aritm_sec_erros:eq:bx1m},
\end{align}
a qual não sofre mais de cancelamento catastrófico. Observamos que também pode ocorrer cancelamento catastrófico no cálculo de $x_2$ pela fórmula \eqref{cap_aritm_sec_erros:eq:cancela_bx2}, no caso de $b$ ser negativo.
\end{ex}

\subsection{Exercícios Resolvidos}

\begin{exeresol}
  O número de Euler é definido por
  \begin{equation}
    e = \sum_{n=0}^\infty \frac{1}{n!}
  \end{equation}
  Determine o erro relativo da aproximação de $e$ pelo truncamento da série com 4 termos.
\end{exeresol}
\begin{resol}
  Denotamos $x = e$ e
  \begin{align}
    \tilde{x} &= \sum_{n=0}^3\frac{1}{n!}\\
              &= \frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!}\\
              &= \frac{1}{1} + \frac{1}{1} + \frac{1}{2} + \frac{1}{6}\\
              &= 2 + \frac{1}{2} + \frac{1}{6}\\
              &= \frac{16}{6}
  \end{align}
  O erro relativo é
  \begin{lstlisting}
    >>> import math as m
    >>> x = m.e
    >>> xa = 16./6
    >>> eabs = m.fabs(x-xa)
    >>> erel = eabs/m.fabs(x)
    >>> print(f"{erel*100:1.1f} %")
    1.9 %
  \end{lstlisting}
  Concluímos que o erro relativo é de $1,9\%$.
\end{resol}

\begin{exeresol}
  Calcule o número de condicionamento $\kappa_f(x)$ para $f(x) = x^n$.
\end{exeresol}
\begin{resol}
  Calculamos o número de condicionamento como segue
  \begin{align}
    \kappa_f(x) &= \left|\frac{xf'(x)}{f(x)}\right|\\
                &= \left|\frac{x\cdot nx^{n-1}}{x^n}\right|\\
                &= \left|\frac{nx^n}{x^n}\right|\\
                &= n,\quad x\neq 0.
  \end{align}
\end{resol}

\begin{exeresol}
  Calcule as raízes do seguinte polinômio quadrático
  \begin{equation}
    p(x) = 10^{-6}x^2 + 10^2x + 3\times 10^{-3}
  \end{equation}
  com $10$ dígitos significativos corretos.
\end{exeresol}
\begin{resol}
  As raízes do polinômio quadrático podem ser calculados pela fórmula de Bhaskara
  \begin{align}
    x_1 &= \frac{-b + \sqrt{b^2 - 4ac}}{2a}\label{cap_aritm_sec_erros:eq:bx1}\\
    x_2 &= \frac{-b - \sqrt{b^2 - 4ac}}{2a}
  \end{align}
  No entanto, a computação da raiz $x_1$ sofre de cancelamento catastrófico. Para contornar este problema, usamos \eqref{cap_aritm_sec_erros:eq:bx1m}, i.e.
  \begin{equation}
    x_1 = \frac{-2c}{b + \sqrt{b^2 - 4ac}}
  \end{equation}

  
  Com o código
  \begin{lstlisting}
    import math as m

    a = 1e-6
    b = 1e2
    c = 3e-3

    delta = b**2 - 4*a*c

    x1 = -2*c/(b + m.sqrt(delta))
    x2 = (-b - m.sqrt(delta))/(2*a)

    print(f"{x1:1.9e}, {x2:1.9e}")
  \end{lstlisting}
  obtemos as saídas
  \begin{lstlisting}
    x_1 = -3.000000000e-05
    x_2 = -1.000000000e+08
  \end{lstlisting}
  
\end{resol}

\subsection{Exercícios}

\begin{exer}\label{exer:erro_abs}
  Calcule o erro absoluto na aproximação de
  \begin{enumerate}[a)]
  \item $\pi$ por $3,14$.
  \item $10e$ por $27,18$.
  \end{enumerate}
  Forneça as respostas com $4$ dígitos significativos.
\end{exer}
\begin{resp}
  a)~$1,593\times 10^{-3}$; b)~$2,818\times 10^{-1}$;
\end{resp}

\begin{exer}\label{exer:erro_rel}
  Calcule o erro relativo na aproximação de
  \begin{enumerate}[a)]
  \item $\pi$ por $3,14$.
  \item $10e$ por $27,18$.
  \end{enumerate}
  Forneça as respostas em porcentagem.
\end{exer}
\begin{resp}
  a)~$0,051\%$; b)~$0,01\%$;
\end{resp}

\begin{exer}\label{exer:dig_corr}
  Com quantos dígitos significativos corretos
  \begin{enumerate}[a)]
  \item $3,13$ aproxima $\pi$?
  \item $27,21$ aproxima $10e$?
  \end{enumerate}
\end{exer}
\begin{resp}
  a)~$3$; b)~$3$
\end{resp}


\begin{exer}
  Obtenha uma estimativa do erro de truncamento em se aproximar o valor de $\sen(1)$ usando-se $p_5(1)$, onde $p_5(x)$ é o polinômio de Taylor de grau 5 da função $\sen(x)$ em torno de $x=0$.
\end{exer}
\begin{resp}
  $1/6! \approx 1,4\times 10^{-3}$.
\end{resp}

\begin{exer}\label{exer:properro_abs1}
  Considerando que $x=2\pm 0,1$, estime o erro absoluto em se calcular $y = e^{-x^2}\cos(\pi x/3)$. Forneça a estimativa com $7$ dígitos significativos por arredondamento.
\end{exer}
\begin{resp}
  $2,002083\times 10^{-3}$
\end{resp}

\begin{exer}\label{exer:properro_abs2}
  Considerando que $x=2\pm 2\%$ e $y=1,5\pm 0,3$, estime o erro absoluto em se calcular $y = e^{-x^2}\cos(\pi y/3)$. Forneça a estimativa com $6$ dígitos significativos por arredondamento.
\end{exer}
\begin{resp}
  $5,75403\times 10^{-3}$
\end{resp}

\begin{exer}\label{exer:cancela_1}
  Considere a computação de
  \begin{equation}
    y = \frac{1 - \cos(h)}{h}
  \end{equation}
para $h=10^{-9}$. Compute o valor de $y$ reescrevendo esta expressão de forma a mitigar o cancelamento catastrófico. Forneça o valor computado de $y$ com $2$ dígitos significativos por arredondamento.
\end{exer}
\begin{resp}
  $5,0\times 10^{-10}$
\end{resp}
