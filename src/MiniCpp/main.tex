%Este trabalho está licenciado sob a Licença Atribuição-CompartilhaIgual 4.0 Internacional Creative Commons. Para visualizar uma cópia desta licença, visite http://creativecommons.org/licenses/by-sa/4.0/deed.pt_BR ou mande uma carta para Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

\documentclass[12pt]{article}

\input ../preambulo.tex

\lstset {
  language=C++,
}

\makeindex

\begin{document}

\title{Minicurso de C/C++ para Matemática}
\author{Pedro H A Konzen}
\date{\today}
% \ifishtml
% \else
% \addcontentsline{toc}{chapter}{Capa}
% \fi

\maketitle

\tableofcontents

\section{Licença}\label{sec_licenca}
%\addcontentsline{toc}{Section}{Licença}

Este trabalho está licenciado sob a Licença Atribuição-CompartilhaIgual 4.0 Internacional Creative Commons. Para visualizar uma cópia desta licença, visite http://creativecommons.org/licenses/by-sa/4.0/deed.pt\_BR ou mande uma carta para Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.


\section{Sobre a Linguagem}\label{sec_sobrepy}

\hl{C e C++ são \emph{linguagens} de programação \emph{compiladas} de propósito geral}. \hl{A primeira é \emph{estruturada e procedural}}, tendo sido criada em 1972 por Dennis Ritchie\footnote{Dennis Ritchie, 1941-2011, cientista da computação estadunidense. Fonte: \href{https://pt.wikipedia.org/wiki/Dennis_Ritchie}{Wikipédia}.}. A segunda foi inicialmente desenvolvida por Bjarne Stroustrup\footnote{Bjarne Stroustrup, 1950, cientista da computação dinamarquês. Fonte: \href{https://pt.wikipedia.org/wiki/Bjarne_Stroustrup}{Wikipédia}.} como uma extensão da primeira. Em sua mais recente especificação, a \hl{linguagem C++ se caracteriza por ser \emph{multi-paradigma} (\emph{imperativa}, \emph{orientada a objetos} e \emph{genérica})}.

\subsection{Instalação e Execução}

\hl{Códigos C/C++ precisam ser compilados antes de serem executados}. De forma simplificada, o \emph{compilador} é um programa que interpreta e converte o código em um programa executável em computador. Há vários compiladores gratuitos disponíveis na web. Ao longo deste minicurso, usaremos a coleção de compiladores \href{https://gcc.gnu.org/}{GNU GCC} instalados em sistema operacional {\linux}.

\subsubsection{IDE}

\hl{Usar um \emph{ambiente integrado de desenvolvimento} (IDE, em inglês, \textit{integrated development environment}) é a melhor forma de capturar o melhor das linguagens C/C++}. Algumas alternativas são:
\begin{itemize}
\item \href{https://www.eclipse.org/ide/}{Eclipse}
\item \href{https://www.gnu.org/software/emacs/download.html}{GNU Emacs}
\item \href{https://code.visualstudio.com/}{VS Code}
\end{itemize}

\subsection{Olá, mundo!}

Vamos \hl{implementar} nosso primeiro programa C/C++. \hl{Em geral, são três passos: 1. escrever; 2. compilar; 3. executar.}

\begin{enumerate}[1.]
\item \hlemph{Escrever o código}.

  Em seu IDE preferido, digite o código:
\begin{lstlisting}[caption=ola.cc, label=cod:ola]
#include <stdio.h>

int main()
{
  printf("Olá, mundo!\n");
  return 0;
}
\end{lstlisting}
  
\item \hlemph{Compilar}.

Para compilá-lo, digite no terminal de seu sistema operacional
\begin{lstlisting}
$ gcc ola.cc -o ola.x
\end{lstlisting}

\item \hlemph{Executar}.

Terminada a compilação, o arquivo executável \lstinline+ola.x+ é criado. Para executá-lo, digite
\begin{lstlisting}
$ ./ola.x
\end{lstlisting}  
\end{enumerate}


\section{Elementos da Linguagem}\label{sec_elem}

\subsection{Tipos de Dados Básicos}

\hl{Na linguagem C/C++, \emph{dados} são alocados em \emph{variáveis} com tipos declarados}\footnote{Consulte \href{https://en.wikipedia.org/wiki/C_data_types}{Wikipedia: C data type} para uma lista dos tipos de dados disponíveis na linguagem}.

\begin{ex}
  Consideramos o seguinte código.
\begin{lstlisting}[caption=dados.cc]
/* dados.cc
   Exemplo de alocação de variáveis.
*/
#include <stdio.h>

int main() 
{
  // var inteira
  int i = 1;
  // var pto flutuante
  double x;

  x = 2.5;
  char s[6] = "i + x";
  double y = i + x;
  printf("%s = %f\n", s, y);
  return 0;
}
\end{lstlisting}

  Na linha 9, é alocada uma \hlemph{variável do tipo inteira} com \emph{identificador} \lstinline+i+ e \emph{valor} \lstinline+1+. Na linha 11, é alocada uma \hlemph{variável do tipo ponto flutuante} (64~\textit{bits}) com identificador \lstinline+x+.

  Na linha 14, é alocada uma \hlemph{variável do tipo \textit{string}}\footnote{Um arranjo de \lstinline+char+ (caracteres).}. Na linha 15, alocamos uma nova variável \lstinline+y+.
\end{ex}

\begin{obs}\normalfont{(\hl{Comentários e Continuação de Linha}.)}
  Códigos C++ admitem \emph{comentários} e \emph{continuação de linha} como no seguinte exemplo acima. Comentários em linha podem ser feitos com \lstinline+\\+ e de múltiplas linhas com \lstinline+\* ... */+. Linhas de instruções muito compridas podem ser quebradas em múltiplas linhas com a instrução de continuação de linha \lstinline+\+.
\end{obs}

\begin{obs}\normalfont{(\hl{Notação científica}.)}
  Podemos usar \emph{notação científica} em C++. Por exemplo $5.2\times 10^{-2}$ é digitado da seguinte forma \lstinline+5.2e-2+.

\begin{lstlisting}[caption=notacaoCientifica.cpp]
#include <stdio.h>

int main()
{

  int i = -51;
  double x = 5.2e-2;

  // inteiro
  printf("inteiro: %d\n", i);
  // fixada
  printf("fixada: %f\n", x);
  // notação científica
  printf("científica: %e\n", x);
  return 0;
}
\end{lstlisting}
\end{obs}

\begin{exr}
  Antes de implementar, diga qual o valor de \lstinline+x+ após as seguintes instruções.
\begin{lstlisting}
int x = 1;
int y = x;
y = 0;
\end{lstlisting}
  Justifique seu resposta e verifique-a.
\end{exr}

\begin{exr}
  Implemente um código em que a(o) usuária(o) entra com valores para as variáveis \lstinline+x+ e \lstinline+y+. Então, os valores das variáveis são permutados entre si. Dica: a entrada de dados por usuária(o) pode ser feita com o método C/C++ \href{https://cplusplus.com/reference/cstdio/scanf}{scanf} da biblioteca \href{https://cplusplus.com/reference/cstdio}{stdio.h}. Por exemplo,
\begin{lstlisting}
double x;
scanf("%lf", x);
\end{lstlisting}
faz a leitura de um \lstinline+double+ (long float) e o armazena na variável \lstinline+x+.
\end{exr}

\subsection{Operações Aritméticas Elementares}

Os operadores aritméticos elementares são\footnote{Em ordem de precedência.}:
\begin{itemize}
\item[] {\lstinline!*!}, {\lstinline!/!}, {\texttt{\%}} \hlemph{multiplicação, divisão, módulo}
\item[] {\lstinline!+!}, {\lstinline!-!} \hlemph{adição, subtração}
\end{itemize}

\begin{ex}
  Qual é o valor impresso pelo seguinte código?
\begin{lstlisting}
#include <stdio.h>

int main()
{
  printf("%f\n", 2+17%9/2*2-1 );
  return 0;
}
\end{lstlisting}

  Observamos que as operações {\lstinline+*+}, {\lstinline+/+} e {\texttt{\%}} têm precedência maior que as operações {\lstinline!+!} e {\lstinline!-!}. Operações de mesma precedência seguem a ordem da esquerda para direita, conforme escritas na linha de comando. \hl{Usa-se parênteses para alterar a precedência entre as operações}, por exemplo
\begin{lstlisting}
printf("%f\n", (2+17)%9/2*2-1 );
\end{lstlisting}
imprime o resultado \lstinline!-1!. Sim, pois a \hl{divisão inteira} está sendo usada. Para computar a divisão em ponto flutuante, um dos operandos deve ser \lstinline!double!. Para tanto, podemos fazer um \hlemph{\textit{casting}} \lstinline!double((2+17)\%9)/2*2-1! ou, simplesmente, \lstinline!(2+17)\%9/2.*2-1!.
\end{ex}

\begin{obs}\normalfont{(\hl{Precedência das Operações}.)}
Consulte mais informações sobre a precedência de operadores em \href{https://en.wikipedia.org/wiki/Operators_in_C_and_C\%2B\%2B#Operator_precedence}{Wikipedia:Operators in C and C++}.
\end{obs}

\begin{exr}
  Escreva um programa para computar o vértice da parábola
  \begin{equation}
    ax^2 + bx + c = 0,
  \end{equation}
  para $a = 2$, $b = -2$ e $c = 4$. 
\end{exr}

\hl{O operador \texttt{\%} módulo computa o \emph{resto} da divisão inteira}, por exemplo, \lstinline+5\%2+ é igual a \lstinline+1+.

\begin{exr}
  Use C/C++ para computar os inteiros não negativos $q$ e $r$ tais que
  \begin{equation}
    25 = q\cdot 3 + r,
  \end{equation}
  sendo $r$ o menor possível.
\end{exr}

\subsection{Funções e Constantes Elementares}

\hl{A \emph{biblioteca} C/C++ {\href{https://cplusplus.com/reference/cmath}{math.h}} disponibiliza várias funções e constantes elementares}.


\begin{ex}
  O seguinte código, imprime os valores de $\pi$, $\sqrt{2}$ e $\ln e$.
\begin{lstlisting}[caption=mat.cc]
#include <stdio.h>
#include <math.h>

int main()
{
  printf("pi = %.9e\n", M_PI);
  printf("2^(1/2) = %.5f\n", sqrt(2.));
  printf("log(e) = %f\n", log(M_E));
  return 0;
}
\end{lstlisting}
\end{ex}

\begin{obs}\normalfont{(\hl{Compilação e Linkagem}.)}
  A compilação de um código C/C++ envolve a linkagem de bibliotecas. A \lstinline!stdio.h! é linkada de forma automática na compilação. Já, \lstinline!math.h! precisa ser explicitamente linkada com
\begin{lstlisting}
$ gcc foo.cc -lm
\end{lstlisting}
\end{obs}

\begin{obs}\normalfont{(\hl{Logaritmo Natural}.)}
  Notamos que \lstinline+log+ é a função logaritmo natural, i.e. $\ln(x) = \log_e(x)$. A implementação C/C++ para o logaritmo de base 10 é \lstinline!log10(x)!.
\end{obs}

\begin{exr}
  Compute
  \begin{enumerate}[a)]
  \item $\displaystyle \sen\left(\frac{\pi}{4}\right)$
  \item $\displaystyle \log_3(\pi)$
  \item $\displaystyle e^{\log_2(\pi)}$
  \item $\displaystyle \sqrt[3]{-27}$
  \end{enumerate}
\end{exr}

\begin{exr}\label{exr:bhaskara}
  Compute as raízes do seguinte polinômio quadrático
  \begin{equation}
    p(x) = 2x^2 - 2x - 4
  \end{equation}
  usando a fórmula de Bhaskara{\bhaskara}.
\end{exr}

\subsection{Operadores de Comparação Elementares}

Os operadores de comparação elementares são
\begin{itemize}
\item[] {\lstinline+==+} \hlemph{igual a}
\item[] {\lstinline+!=+} \hlemph{diferente de}
\item[] {\lstinline+>+} \hlemph{maior que}
\item[] {\lstinline+<+} \hlemph{menor que}
\item[] {\lstinline+>=+} \hlemph{maior ou igual que}
\item[] {\lstinline+<=+} \hlemph{menor ou igual que}
\end{itemize}
Estes operadores retornam os \emph{valores lógicos} \lstinline!true! (verdadeiro, \lstinline!1!) ou \lstinline!false! (falso, \lstinline!0!).

Por exemplo, temos
\begin{lstlisting}[caption=opComp.cc]
#include <stdio.h>

int main()
{
  int x = 2;
  bool res = x + x == 5;
  printf("2 + 2 == 5? %d", res);
}
\end{lstlisting}

\begin{exr}
  Considere a circunferência de equação
  \begin{equation}
    c: ~(x - 1)^2 + (y + 1)^2 = 1.
  \end{equation}
  Escreva um código em que a(o) usuária(o) entra com as coordenadas de um ponto $P = (x, y)$ e o código verifica se $P$ pertence ao disco determinado por $c$.
\end{exr}

\begin{exr}
  Antes de implementar, diga qual é o valor lógico da instrução \lstinline+sqrt(3) == 3+. Justifique sua resposta e verifique!
\end{exr}

\subsection{Operadores Lógicos Elementares}

Os operadores lógicos elementares são:
\begin{itemize}
\item[] {\lstinline+&&+} \hlemph{e lógico}
\item[] {\lstinline+||+} \hlemph{ou lógico}
\item[] {\lstinline+!+} \hlemph{não lógico}
\end{itemize}

\begin{ex}\normalfont{(\hl{Tabela Booleana do \texttt{\&\&}}.)}
  A tabela booleana{\boole} do \lstinline!e! lógico é
  \begin{center}
    \begin{tabular}[H]{ll|l}
      {\lstinline+A+} & {\lstinline+B+} &  {\lstinline+A && B+}\\\hline
      {\lstinline+true+} & {\lstinline+true+} & {\lstinline+true+} \\
      {\lstinline+true+} & {\lstinline+false+} & {\lstinline+false+} \\
      {\lstinline+false+} & {\lstinline+true+} & {\lstinline+false+} \\
      {\lstinline+false+} & {\lstinline+false+} & {\lstinline+false+} \\\hline
    \end{tabular}
  \end{center}

  O seguinte código, monta essa tabela booleana, verifique!
\begin{lstlisting}
#include <stdio.h>

int main()
{
  bool T = true;
  bool F = false;
  printf("A   | B   | A && B\n");
  printf("%d   | %d   | %d\n", T, T, T&&T);
  printf("%d   | %d   | %d\n", T, F, T&&F);
  printf("%d   | %d   | %d\n", F, T, F&&T);
  printf("%d   | %d   | %d\n", F, F, F&&F);
}
\end{lstlisting}
\end{ex}

\begin{exr}
  Construa as tabelas booleanas do operador \lstinline+||+ e do \lstinline+!+.
\end{exr}

\begin{exr}
  Escreva um código para verificar as seguintes comparações
  \begin{enumerate}[a)]
  \item $1.4 <= \sqrt{2} < 1.5$.
  \item $|x| < 1$, $x = \sen(\pi/3)$.
  \item $|x| > \frac{1}{2}$, $x = \cos(\pi**2)$.
  \end{enumerate}
\end{exr}

\begin{exr}
  Considere um retângulo $r: ~ABDC$ de vértices $A = (1, 1)$ e $D = (2, 3)$. Crie um código em que a(o) usuária(o) informa as coordenadas de um ponto $P = (x, y)$ e o código verifica cada um dos seguintes itens:
  \begin{enumerate}
  \item $P\in r$.
  \item $P\in \p r$.
  \item $P\not\in \overline{r}$.
  \end{enumerate}
\end{exr}

\begin{exr}
  Implemente uma instrução para computar o operador \lstinline+xor+ (ou exclusivo). Dadas duas afirmações \lstinline+A+ e \lstinline+B+, \lstinline+A xor B+ é \lstinline+true+ no caso de uma, e somente uma, das afirmações ser \lstinline+true+, caso contrário é \lstinline+false+.
\end{exr}

\subsection{Arranjos}

\hl{Um \emph{arranjo}\footnote{Em inglês, \textit{array}} é uma sequência de dados do mesmo tipo}. Os elementos dos arranjos são indexados\footnote{O índice é um inteiro não negativo, sendo o primeiro elemento indexado por $0$ (zero).} e mutáveis (podemos ser alterados por nova atribuição).

\begin{ex}
  No código abaixo, alocamos o ponto $P = (2, 3)$ e o vetor $\pmb{v} = (2.5, \pi, -1.)$ como arranjos.
\begin{lstlisting}
#include <stdio.h>
#include <math.h>

int main()
{
  // P = (2, 3)
  int P[2] = {2, 3};
  printf("P = (%d, %d)\n", P[0], P[1]);
  
  double v[3];
  v[0] = 2.5;
  v[1] = M_PI;
  v[2] = -1.;
  printf("v = (%lf, %lf, %lf)\n", v[0], v[1], v[2]);
  
  return 0;
}
\end{lstlisting}
\end{ex}

\begin{exr}
  Escreva um código em que a(o) usuária(o) entra com um ponto $P = (x, y)$ e o programa informe se $P$ pertence ao disco determinado pela circunferência de equação $(x-1)^2 + y^2 = 4$. Use de um arranjo para alocar o ponto $P$.
\end{exr}

\begin{exr}
  Considere os vetores
  \begin{align}
    &\pmb{v} = (-1., 2., 1.)\\
    &\pmb{w} = (1., -3., 2.).
  \end{align}
  Faça um código que aloca os vetores como arranjos e imprime o vetor soma $\pmb{v} + \pmb{w}$.
\end{exr}

\begin{exr}
  Considere a matriz
  \begin{equation}
    A =
    \begin{vmatrix}
      1. & -2.\\
      3. & 3.
    \end{vmatrix}.
  \end{equation}
  Faça um código que aloca a matriz como um arranjo bidimensional (um arranjo de arranjos) e compute seu determinante.
\end{exr}

\section{Elementos da Programação Estruturada}\label{sec_progest}

\hl{C/C++ são linguagens procedurais}\footnote{C++ também é orientada-a-objetos.} e contém instruções para a \hlemph{programação estruturada}. Neste paradigma de programação, as computações são organizadas em sequências de blocos computacionais e, um bloco inicia sua computação somente após o bloco anterior tiver terminado. Contam com estruturas de \hlemph{ramificação} (seleção de blocos), \hlemph{repetição} de blocos e definição de \hlemph{funções/métodos} (sub-blocos computacionais).

\subsection{Métodos/Funções}

\hl{Um \emph{método} (ou \emph{função}) é um subprograma (ou subbloco computacional) que pode ser chamado/executado em qualquer parte do programa principal}. Todo código C/C++ inicia-se no método \lstinline+main()+, consulte o Código~\ref{cod:ola}. A sintaxe de definição de um método é
\begin{lstlisting}
typeOut foo(typeIn0 x0, typeIn1 x1, ..., typeInN x2)
{
  typeOut out;
  statment0;
  statment1;
  ...;
  statmentN;
  return out;
}
\end{lstlisting}
Aqui, \lstinline+typeOut+ denota o tipo da saída, \lstinline+foo+ denota o identificador/nome do método, \lstinline+typeIn0 x1+, \lstinline+typeIn1 x2+, ..., \lstinline+typeInN x3+ são os tipos e identificadores dos parâmetros de entrada\footnote{Parâmetros de entrada são opcionais}. O escopo do método é delimitado entre chaves e pode conter qualquer instrução (\textit{statment}) C/C++. O método é encerrado\footnote{No encerramento do método o código retorna ao programa principal.} quando terminado seu escopo ou ao encontrar a instrução \lstinline+return+. Esta instrução,também, permite o retorno de um dado do mesmo tipo da saída do método.

\begin{ex}
  Vamos considerar a função
  \begin{equation}
    f(x) = 2x - 3.
  \end{equation}

  \begin{enumerate}[a)]
  \item No código abaixo, o método $f$ computa a função e imprime seu valor\footnote{\lstinline+void+ é a instrução para ``no type''.}.
\begin{lstlisting}[caption=method.cc]
#include <stdio.h>

void f(double x)
{
  double y = 2.*x - 3.;
  printf("f(%lf) = %lf\n", x, y);
}

int main()
{
  f(0.);
  double x = -1.;
  f(x);
  double y = 2.;
  f(y);
  return 0;
}      
\end{lstlisting}

  \item Nesta versão do código, o método \lstinline+f+ retorna o valor computado da função $f$ e é o método principal \lstinline+main+ que imprime o resultado.
\begin{lstlisting}
#include <stdio.h>

double f(double x)
{
  return 2.*x - 3.;
}

int main()
{
  double y = f(0.);
  printf("f(%lf) = %lf\n", 0., y);
  printf("f(%lf) = %lf\n", -1., f(-1.));
  double z = 2.;
  printf("f(%lf) = %lf\n", z, f(z));
  return 0;
}
\end{lstlisting}
  \end{enumerate}  
\end{ex}

\begin{exr}
  Implemente uma função para computar as raízes de um polinômio de grau 1 $p(x) = ax + b$. Assuma que $a\neq 0$.
\end{exr}

\begin{exr}
  Implemente uma função para computar as raízes reais de um polinômio de grau 2 $p(x) = ax^2 + bx + c$. Assuma que $p$ tenha raízes reais.
\end{exr}

\begin{exr}
  Considerando vetores em $\mathbb{R}^3$
  \begin{gather}
    x = (x_1, x_2, x_3),\\
    y = (y_1, y_2, y_3),
  \end{gather}
  implemente um código que contenha:
  \begin{enumerate}[a)]
  \item função para computação do vetor soma $\pmb{x}+\pmb{y}$.
  \item função para computação do produto escalar $\pmb{x}\cdot\pmb{y}$.
  \end{enumerate}
\end{exr}

\begin{exr}
  Implemente uma função que computa o determinante de matrizes reais $2\times 2$. 
\end{exr}

\begin{exr}
  Implemente uma função que computa a multiplicação matrix-vetor $Ax$, com $A$ $2\times 2$ e $x$ um vetor coluna de dois elementos.
\end{exr}

\begin{exr}(Recursividade) Implemente uma função recursiva para computar o fatorial de um número natural $n$, i.e. $n!$.  
\end{exr}

\subsection{Ramificação}

Uma estrutura de ramificação é uma instrução para a tomada de decisões durante a execução de um programa. Nas linguagens C/C++ usa-se a sintaxe
\begin{lstlisting}
if (condition0) {
  block0;
} else if (condition1) {
  block1;
} else {
  block2;
}
\end{lstlisting}
A instrução \lstinline+if+ permite a execução do bloco computacional \lstinline+block0+ somente no caso de a \lstinline+condition0+ seja \lstinline+true+ (verdadeira). A instrução \lstinline+else if+ somente é verificada quando \lstinline+condition0 == false+. Neste caso, o \lstinline+block1+ é executado somente se \lstinline+condition1 == true+. Senão, \lstinline+block2+ é executado.

\begin{ex}
  Os seguintes códigos computam os zeros da função
  \begin{equation}
    f(x) = ax + b,
  \end{equation}
  para parâmetros informados por usuária(o).
  \begin{enumerate}[a)]
  \item Caso restrito a raiz real única.
\begin{lstlisting}
#include <stdio.h>

int main()
{
  double a,b;
  printf("a = ");
  scanf("%lf", &a);
  printf("b = ");
  scanf("%lf", &b);

  if (a != 0.) {
    double x = -b/a;
    printf("x = %lf\n", x);
  }

  return 0;
}
\end{lstlisting}
    
  \item Caso de raiz real única ou múltiplas.
\begin{lstlisting}
#include <stdio.h>

int main()
{
  double a,b;
  printf("a = ");
  scanf("%lf", &a);
  printf("b = ");
  scanf("%lf", &b);

  if (a != 0.) {
    double x = -b/a;
    printf("x = %lf\n", x);
  } else if ((a == 0.) && (b == 0.)) {
    printf("Todo x real é zero da função.\n");
  }

  return 0;
}
\end{lstlisting}

  \item Caso de raiz real única, ou múltiplas ou nenhuma.
\begin{lstlisting}
#include <stdio.h>

int main()
{
  double a,b;
  printf("a = ");
  scanf("%lf", &a);
  printf("b = ");
  scanf("%lf", &b);

  if (a != 0.) {
    double x = -b/a;
    printf("x = %lf\n", x);
  }

  return 0;
}
\end{lstlisting}
  \end{enumerate}
\end{ex}

\begin{exr}
  Implemente um código que contenha uma função que recebe dois números $n$ e $m$ e imprime o maior deles.
\end{exr}

\begin{exr}
  Implemente um código que contenha uma função que recebe os coeficientes de um polinômio
  \begin{equation}
    p(x) = ax^2 + bx + c
  \end{equation}
  e classifique-o como um polinômio de grau 0, 1 ou 2.
\end{exr}

\begin{exr}
  Implemente um código que contenha uma função para a computação das raízes de um polinômio de segundo grau.
\end{exr}


\subsection{Repetição}

\hl{Estruturas de repetição são instruções que permitem a execução repetida de um bloco computacional}. São três instruções disponíveis \lstinline+while+, \lstinline+do ... while+ e \lstinline+for+.

\subsubsection{\texttt{while}}

A \hl{sintaxe da instrução \texttt{while}} é
\begin{lstlisting}
while (condition) {
   block
}
\end{lstlisting}
Isto é, enquanto (\lstinline+while+) a expressão \lstinline+condition == true+, o bloco computacional \lstinline+block+ é repetidamente executado. Ao final de cada execução, a condição é novamente verificada. Quando \lstinline+condition == false+, \lstinline+block+ não é executado e o código segue para a primeira instrução após o escopo do \lstinline+while+.

\begin{ex}
  O seguinte código computa a soma dos $10$ primeiros termos da progressão geométrica
  \begin{equation}
    a_i = 2^{-i},
  \end{equation}
  para $i = 0, 1, 2, \ldots$.

\begin{lstlisting}[caption=while.cc]
#include <stdio.h>
#include <math.h>

int main()
{
  int i = 0;
  double s = 0.;
  while (i < 10) {
    s = s + pow(0.5, double(i));
    i += 1;
  }
  printf("s = %lf\n", s);
  return 0;
}
\end{lstlisting}
\end{ex}

\begin{obs}
  As instruções de controle \href{https://en.cppreference.com/w/cpp/language/break}{\lstinline!break!}, \href{https://en.cppreference.com/w/cpp/language/continue}{\lstinline!continue!} são bastante úteis em várias situações. A primeira, encerra as repetições e, a segunda, pula para uma nova repetição.
\end{obs}

\begin{exr}
  Use \lstinline!while! para imprimir os dez primeiros números ímpares.
\end{exr}

\begin{exr}
  Crie uma função para a computação da soma de dois vetores $\pmb{x}, \pmb{y}\in\mathbb{R}^n$, com dado $n\geq 0$.
\end{exr}

\begin{exr}
  Use a instrução \lstinline!while! para escreva uma função que retorne o $n$-ésimo termo da função de Fibonacci{\fibonacci}, $n\geq 1$.
\end{exr}

\subsection{\texttt{do ... while}}

\hl{Diferentemente da instrução \texttt{while}, a \texttt{do ... while} verifica a condição de repetição ao final do escopo do seu bloco computacional}.

\begin{ex}
  O seguinte código computa a soma dos $10$ primeiros termos da progressão geométrica
  \begin{equation}
    a_i = 2^{-i},
  \end{equation}
  para $i = 0, 1, 2, \ldots$.

\begin{lstlisting}[caption=doWhile.cc]
#include <stdio.h>
#include <math.h>

int main()
{
  int i = 0;
  double s;
  do {
    s += pow(0.5, double(i));
    i += 1;
  } while (i < 10);
  printf("s = %lf\n", s);
  return 0;
}
\end{lstlisting}  
\end{ex}

\begin{exr}
  Uma aplicação do Método Babilônico\footnote{Matemática Babilônica, matemática desenvolvida na Mesopotâmia, desde os Sumérios até a queda da Babilônia em 539 a.C.. Fonte: \href{https://pt.wikipedia.org/wiki/Matem\%C3\%A1tica\_babil\%C3\%B4nica}{Wikipédia}.} para a aproximação da solução da equação $x^2-2 = 0$, consiste na iteração
  \begin{gather}
    x_0 = 1,\\
    x_{i+1} = \frac{x_i}{2} + \frac{1}{x_i},\quad i=0,1,2,\ldots
  \end{gather}
  Faça um código com \lstinline+while+ para computar aproximação $x_{i}$, tal que $|x_{i}-x_{i-1}|<10^{-5}$.
\end{exr}

\subsubsection{\texttt{for}}

\hl{A estrutura \texttt{for} tem a sintaxe}
\begin{lstlisting}
for (init; condition; iter) {
  block;
}
\end{lstlisting}
onde, \lstinline!init! é a instrução de inicialização, \lstinline+condition+ é o critério de parada, \lstinline+iter+ é a instrução do iterador.

\begin{ex}
  O seguinte código computa a soma dos $10$ primeiros termos da progressão geométrica
  \begin{equation}
    a_i = 2^{-i},
  \end{equation}
  para $i = 0, 1, 2, \ldots$.
\begin{lstlisting}
#include <stdio.h>
#include <math.h>

int main()
{
  double s = 0;
  for (int i=0; i<10; ++i) {
    s += pow(2., double(-i));
  }
  printf("s = %lf\n", s);
  return 0;
}
\end{lstlisting}
\end{ex}

\begin{exr}
  Use a instrução \lstinline!for! para escreva uma função que retorne o $n$-ésimo termo da função de Fibonacci{\fibonacci}, $n\geq 1$.
\end{exr}

\begin{exr}
  Implemente uma função para computar o produto escalar de dois vetores de $n$ elementos. Use a instrução de repetição \lstinline!for! e assuma que os vetores estão alocados como um arranjo \lstinline!double!.
\end{exr}

\begin{exr}
  Implemente uma função para computar a multiplicação de uma matriz $A$ $n\times n$ por um vetor coluna $x$ de $n$ elementos. Use a instrução \lstinline!for! e assuma que o vetor e a matriz estejam alocadas como arranjos \lstinline!double!.
\end{exr}

\begin{exr}
  Implemente uma função para computar a multiplicação de uma matriz $A$ $n\times m$ por uma matriz $B$ de $m\times n$. Use a instrução \lstinline!for! e assuma que as matrizes estão alocadas como arranjos \lstinline+double+.
\end{exr}

\section{Elementos da Computação Matricial}\label{sec_mat}

\hl{{\gsl} (GNU Scientific Library) é uma biblioteca de métodos numéricos para C/C++}. É um software livre sobre a \textit{GNU General Public License} e está disponível em
\begin{center}
  \url{https://www.gnu.org/software/gsl/}.
\end{center}

A biblioteca fornece uma grande número de rotinas matemáticas para várias áreas da análise numérica. Aqui, vamos nos concentrar em uma rápida introdução à computação matricial.

\subsection{Vetores}\label{sec_mat_subsec_vet}

A alocação de um vetor no {\gsl} segue o estilo de \lstinline+malloc+ (alocação de memória) e \lstinline+free+ (liberação de memória). O \hl{suporte a vetores} requer a importação da biblioteca \hl{\texttt{gsl\_vector.h}}.

\begin{ex}
  No seguinte código, alocamos e imprimimos o seguinte vetor
  \begin{equation}
    \pmb{v} = (\sqrt{2}, 1, 3.5, \pi).
  \end{equation}

\begin{lstlisting}[caption=vector.cc]
#include <stdio.h>

// GSL const e funs matemáticas
#include <gsl/gsl_math.h>
// GSL vetores
#include <gsl/gsl_vector.h>

int main() {
  // alocação de memória
  gsl_vector *v = gsl_vector_alloc(4);

  // atribuição
  gsl_vector_set(v, 0, sqrt(2.));
  gsl_vector_set(v, 1, 1.);
  gsl_vector_set(v, 2, 3.5);
  gsl_vector_set(v, 3, M_PI);

  // acesso e impressão
  for (int i=0; i<4; ++i) {
    printf("v_%d = %g\n", i, gsl_vector_get(v, i));
  }
  
  // liberação de memória
  gsl_vector_free(v);
}
\end{lstlisting}

  A compilação desse código requer a lincagem com a biblioteca {\gsl}:
\begin{lstlisting}
$ gcc vetor.cc -lgsl -lgslcblas -lm
\end{lstlisting}
\end{ex}

\begin{obs}\normalfont{(\hl{Inicialização}.)}
  Alternativamente, a alocação com o método
\begin{lstlisting}
gsl_vector *gsl_vector_calloc(size_t n)
\end{lstlisting}
  cria um vetor e inicializada todos os seus elementos como zero. Outros métodos de inicialização estão disponíveis, consulte \href{https://www.gnu.org/software/gsl/doc/html/vectors.html#initializing-vector-elements}{GSL Docs: Initializing vector elements}.
\end{obs}

\subsubsection{Operações com Vetores}

\hl{Operações básicas envolvendo vetores} do {\gsl} estão disponíveis com os seguintes métodos\footnote{Mais detalhes, consulte \href{https://www.gnu.org/software/gsl/doc/html/vectors.html\#vector-operations}{GNU Docs: Vector operations}.}:
\begin{itemize}
\item \hl{\texttt{int gsl\_vector\_add(gsl\_vector *a, const gsl\_vector *b)}}

  Computa a adição vetorial \lstinline!a + b! e o resultado é armazenado no vetor \lstinline+a+.

\item \hl{\texttt{int gsl\_vector\_sub(gsl\_vector *a, const gsl\_vector *b)}}

  Computa a subtração vetorial \lstinline!a - b! e o resultado é armazenado no vetor \lstinline!a!.

\item \hl{\texttt{int gsl\_vector\_mul(gsl\_vector *a, const gsl\_vector *b)}}

  Computa a multiplicação elemento-a-elemento \lstinline!a*b! e armazena o resultado no vetor \lstinline!a!.

\item \hl{\texttt{int gsl\_vector\_div(gsl\_vector *a, const gsl\_vector *b)}}

  Computa a divisão elemento-a-elemento \lstinline!a/b! e armazena o resultado no vetor \lstinline!a!.

\item \hl{\texttt{int gsl\_vector\_scale(gsl\_vector *a, const double x)}}

  Computa a multiplicação por escalar \lstinline!x*a! e armazena o resultado no vetor \lstinline!a!.

\item \hl{\texttt{int gsl\_vector\_add\_constant(gsl\_vector *a, const double x)}}

  Re-computa o vetor \lstinline!a! somando o escalar \lstinline!x! a cada um de seus elementos.

\item \hl{\texttt{double gsl\_vector\_sum(const gsl\_vector *a)}}

  Retorna a soma dos elementos do vetor \lstinline!a!.
\end{itemize}

\begin{obs}\normalfont{(\hl{Suporte BLAS}.)}
  O {\gsl} também fornece suporte a biblioteca BLAS (\textit{Basic Linear Algebra Subprograms}) pelo \lstinline!gsl_blas.h!. Operações vetoriais estão disponíveis no nível 1 da biblioteca. Para mais informações e acesso à documentação sobre os métodos disponíveis, consulte
  \begin{center}
    \url{https://www.gnu.org/software/gsl/doc/html/blas.html}.
  \end{center}
\end{obs}

\begin{ex}
  No código abaixo, computamos $\pmb{w} = \alpha \pmb{u} + \pmb{v}$ para o escalar $\alpha = 2$ e os vetores
  \begin{equation}
    \begin{aligned}
      &\pmb{u} = (1, -2, 0.5),\\
      &\pmb{v} = (2, 1, -1.5).
    \end{aligned}
  \end{equation}

\begin{lstlisting}[caption=axpy.cc]
#include <stdio.h>

// GSL vetores
#include <gsl/gsl_vector.h>
// GSL BLAS
#include <gsl/gsl_blas.h>

int main() {

  // alpha
  double alpha = 2.;
  
  // u
  gsl_vector *u = gsl_vector_alloc(3);
  gsl_vector_set(u, 0, 1.);
  gsl_vector_set(u, 1, -2.);
  gsl_vector_set(u, 2, 0.5);

  // v
  gsl_vector *v = gsl_vector_alloc(3);
  gsl_vector_set(v, 0, 2.);
  gsl_vector_set(v, 1, 1.);
  gsl_vector_set(v, 2, -1.5);

  // w = alpha*u + v
  // alloc w
  gsl_vector *w = gsl_vector_alloc(3);
  // copy w = v
  gsl_vector_memcpy(w, v);
  // w = alpha*u + w
  gsl_blas_daxpy(alpha, u, w);
  
  // imprime
  for (int i=0; i<3; ++i) {
    printf("w_%d = %g\n", i, gsl_vector_get(w, i));
  }
  
  // liberação de memória
  gsl_vector_free(v);
}
\end{lstlisting}
\end{ex}

\begin{exr}
  Faça um código para computar o produto escalar $\pmb{x}\cdot\pmb{y}$ dos vetores
  \begin{align}
    &\pmb{x} = (1.2, \ln(2), 4),\\
    &\pmb{y} = (\pi^2, \sqrt{3}, e).
  \end{align}
  \begin{enumerate}[a)]
  \item Crie sua própria função \lstinline+double dot(const gsl_vector *x, const gsl_vector *y)+ que recebe os vetores e retorna o produto escalar deles.
  \item Use o método BLAS \href{https://www.gnu.org/software/gsl/doc/html/blas.html\#c.gsl_blas_dsdot}{\lstinline+gsl_blas_dsdot+}.
  \end{enumerate}
\end{exr}

\begin{exr}
  Faça um código para computar a norma $L^2$ do vetor
  \begin{equation}
    \pmb{x} = (1.2, \log_{10}^2(2), 0.5).
  \end{equation}
  \begin{enumerate}[a)]
  \item Crie sua própria função \lstinline+double norm2(const gsl_vector *x)+ que recebe o vetor e retorna sua norma.
  \item Use o método BLAS \href{https://www.gnu.org/software/gsl/doc/html/blas.html\#c.gsl_blas_dnrm2}{\lstinline+gsl_blas_dnrm2+}.
  \end{enumerate}
\end{exr}

\subsection{Matrizes}\label{sec_mat_subsec_mat}

Assim como vetores, a alocação de matrizes no {\gsl} segue o estilo \lstinline!malloc! e \lstinline!free!. O \hl{suporte a matrizes} requer a importação da biblioteca \hl{\texttt{gsl\_matrix.h}}.

\begin{ex}
  No seguinte código, alocamos e imprimimos a matriz
  \begin{equation}
    A =
    \begin{bmatrix}
      1.5 & -1 & \pi & 2.3\\
      \sqrt[3]{25} & 2.1 & -3.5 & 3\\
      \log 15 & 0 & 2.5^3 & -1.7
    \end{bmatrix}
  \end{equation}

\begin{lstlisting}[caption=matriz.cc]
#include <stdio.h>

// GSL
#include <gsl/gsl_math.h>
#include <gsl/gsl_matrix.h>

int main()
{
  // alocação
  gsl_matrix *A = gsl_matrix_alloc(3, 4);

  // população
  gsl_matrix_set(A, 0, 0, 1.5);
  gsl_matrix_set(A, 0, 1, -1.);
  gsl_matrix_set(A, 0, 2, M_PI);
  gsl_matrix_set(A, 0, 3, 2.3);

  gsl_matrix_set(A, 1, 0, cbrt(25.));
  gsl_matrix_set(A, 1, 1, 2.1);
  gsl_matrix_set(A, 1, 2, -3.5);
  gsl_matrix_set(A, 1, 3, 3.);

  gsl_matrix_set(A, 2, 0, log10(15.));
  gsl_matrix_set(A, 2, 1, 0.);
  gsl_matrix_set(A, 2, 2, pow(2.5, 3.));
  gsl_matrix_set(A, 2, 3, -1.7);

  // imprime
  printf("A = \n");
  for (int i=0; i<A->size1; ++i) {
    for (int j=0; j<A->size2; ++j)
      printf("%g ", gsl_matrix_get(A, i, j));
    printf("\n");
  }

  gsl_matrix_free(A);
  return 0;
}
\end{lstlisting}
\end{ex}

\begin{obs}\normalfont{(\hl{Inicialização de Matrizes}.)}
  Matrizes podem ser inicializadas com todos os seus elementos nulos usando
\begin{lstlisting}
gsl_matrix *gsl_matrix_calloc(size_t n1, size_t n2)
\end{lstlisting}
  Outros métodos de inicialização também estão disponíveis, consulte
  \begin{center}
    \url{https://www.gnu.org/software/gsl/doc/html/vectors.html#initializing-matrix-elements}.
  \end{center}
\end{obs}

\subsection{Operações Matriciais}

O {\gsl} conta com os seguintes \hl{métodos de operações matriciais}\footnote{Consulte a lista completa em \href{https://www.gnu.org/software/gsl/doc/html/vectors.html\#matrix-operations}{GSL Docs: Matrix operations}.}:
\begin{itemize}
\item \hl{\texttt{int gsl\_matrix\_add(gsl\_matrix *a, const gsl\_matrix *b)}}

  Computa a adição matricial \lstinline!a + b! e armazena o resultado em \lstinline!a!.

\item \hl{\texttt{int gsl\_matrix\_sub(gsl\_matrix *a, const gsl\_matrix *b)}}

  Computa a subtração matricial \lstinline!a - b! e armazena o resultado em \lstinline!a!.

\item \hl{\texttt{int gsl\_matrix\_mul\_elements(gsl\_matrix *a, const gsl\_matrix *b)}}

  Computa a multiplicação elemento-a-elemento \lstinline!a*b! e armazena o resultado em \lstinline!a!.

\item \hl{\texttt{int gsl\_matrix\_div\_elements(gsl\_matrix *a, const gsl\_matrix *b)}}

  Computa a divisão elemento-a-elemento \lstinline!a/b! e armazena o resultado em \lstinline!a!.

\item \hl{\texttt{int gsl\_matrix\_scale(gsl\_matrix *a, const double x)}}

  Computa a multiplicação por escalar \lstinline!x*a! e armazena o resultado em \lstinline!a!.

\item \hl{\texttt{int gsl\_matrix\_add\_constant(gsl\_matrix *a, const double x)}}

  Re-computa a matriz \lstinline+a+ somando \lstinline+x+ a cada um de seus elementos.
\end{itemize}

\begin{obs}\normalfont{(\hl{Operações Matrix-Vetor e Matriz-Matriz}.)}
  Na {\gsl}, \hl{operações matrix-vetor} estão disponíveis no suporte \href{https://www.gnu.org/software/gsl/doc/html/blas.html\#level-2}{BLAS de nível 2}. Já, operações matriz-matriz, no suporte \href{https://www.gnu.org/software/gsl/doc/html/blas.html\#level-2}{BLAS de nível 3}. Consulte a lista completa de métodos em
  \begin{center}
    \url{https://www.gnu.org/software/gsl/doc/html/blas.html\#blas-support}.
  \end{center}
\end{obs}

\begin{ex}
  O seguinte código verifica se $\pmb{x} = (-1, 1, -2)$ é solução do sistema linear
  \begin{equation}
    \begin{aligned}
      &x_1 - x_2 + 2x_3 = -6\\
      &2x_1 + x_2 - x_3 = 1\\
      &-x_1 + x_2 + x_3 = 0
  \end{aligned}
\end{equation}

\begin{lstlisting}[caption=sisLin.cc]
#include <stdio.h>

// GSL
#include <gsl/gsl_math.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>

int main()
{
  // matriz dos coefs
  gsl_matrix *A = gsl_matrix_alloc(3, 3);
  
  gsl_matrix_set(A, 0, 0, 1.);
  gsl_matrix_set(A, 0, 1, -1.);
  gsl_matrix_set(A, 0, 2, 2.);

  gsl_matrix_set(A, 1, 0, 2.);
  gsl_matrix_set(A, 1, 1, 1.);
  gsl_matrix_set(A, 1, 2, -1.);

  gsl_matrix_set(A, 2, 0, -1.);
  gsl_matrix_set(A, 2, 1, 1.);
  gsl_matrix_set(A, 2, 2, 1.);

  // vetor dos termos consts
  gsl_vector *b = gsl_vector_alloc(3);

  gsl_vector_set(b, 0, -6.);
  gsl_vector_set(b, 1, 1.);
  gsl_vector_set(b, 2, 0.);

  // vetor solução ?
  gsl_vector *x = gsl_vector_alloc(3);

  gsl_vector_set(x, 0, -1.);
  gsl_vector_set(x, 1, 1.);
  gsl_vector_set(x, 2, -2.);

  // verificação
  // y = Ax
  gsl_vector *y = gsl_vector_alloc(3);
  gsl_blas_dgemv(CblasNoTrans, 1., A, x, 0., y);

  // y - b
  gsl_vector_sub(y, b);
  
  if (gsl_blas_dnrm2(y) < 1e-14)
    printf("x é solução do sistema.\n");
  else
    printf("x não é solução do sistema.\n");

  gsl_matrix_free(A);
  gsl_vector_free(b);
  gsl_vector_free(x);
  gsl_vector_free(y);
  
  return 0;
}
\end{lstlisting}
\end{ex}

\begin{exr}
  Crie uma função para computar a norma de Frobenius de uma matriz $A$. Teste seu código com a matriz
  \begin{equation}
    A =
    \begin{bmatrix}
      -4 & -3 & -2\\
      -1 & 0 & 1\\
      2 & 3 & 4
    \end{bmatrix}.
  \end{equation}
\end{exr}

\begin{exr}
  Faça um código para verificar se a matriz
  \begin{equation}
    A =
    \begin{bmatrix}
      1 & 0 & 0\\
      1 & 3 & 1\\
      1 & 2 & 0
    \end{bmatrix}
  \end{equation}
  é inversa de
  \begin{equation}
    B =
    \begin{bmatrix}
      1 & 0 & 0\\
      -0.5 & 0 & 0.5\\
      0.5 & 1 & -1.5
    \end{bmatrix}.
  \end{equation}
\end{exr}

\subsection{Sistemas Lineares}

A {\gsl} tem \hl{suporte à álgebra linear} pelo módulo \href{https://www.gnu.org/software/gsl/doc/html/linalg.html}{\lstinline!gsl_linalg.h!}. Métodos para a decomposição LU, QR, Cholesky entre tantos outros métodos estão disponíveis. Consulte a lista completa em
\begin{center}
  \url{https://www.gnu.org/software/gsl/doc/html/linalg.html\#linear-algebra}.
\end{center}

\begin{ex}
  No seguinte código, computamos a solução do sistema
  \begin{equation}
    \begin{aligned}
      &x_1 - x_2 + 2x_3 = -6\\
      &2x_1 + x_2 - x_3 = 1\\
      &-x_1 + x_2 + x_3 = 0
    \end{aligned}
  \end{equation}
  pelo método LU.

\begin{lstlisting}[caption=lu.cc]
#include <stdio.h>

// GSL
#include <gsl/gsl_vector.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_linalg.h>

int main()
{
  // matriz dos coefs
  gsl_matrix *A = gsl_matrix_alloc(3, 3);
  
  gsl_matrix_set(A, 0, 0, 1.);
  gsl_matrix_set(A, 0, 1, -1.);
  gsl_matrix_set(A, 0, 2, 2.);

  gsl_matrix_set(A, 1, 0, 2.);
  gsl_matrix_set(A, 1, 1, 1.);
  gsl_matrix_set(A, 1, 2, -1.);

  gsl_matrix_set(A, 2, 0, -1.);
  gsl_matrix_set(A, 2, 1, 1.);
  gsl_matrix_set(A, 2, 2, 1.);

  // vetor dos termos consts
  gsl_vector *b = gsl_vector_alloc(3);

  gsl_vector_set(b, 0, -6.);
  gsl_vector_set(b, 1, 1.);
  gsl_vector_set(b, 2, 0.);

  // decomposição LU
  // PA = LU
  gsl_permutation *p = gsl_permutation_alloc(3);
  int signum;
  gsl_linalg_LU_decomp(A, p, &signum);

  // solução
  gsl_vector *x = gsl_vector_alloc(3);
  gsl_linalg_LU_solve(A, p, b, x);

  // imprime a solução
  for (int i=0; i<3; ++i)
    printf("x_%d = %g\n", i, gsl_vector_get(x, i));

  gsl_matrix_free(A);
  gsl_vector_free(b);
  gsl_permutation_free(p);
  gsl_vector_free(x);
  
  return 0;
}
\end{lstlisting}
\end{ex}

\begin{exr}\label{exr:sisLinInf}
  Crie sua própria função para a computação da solução de sistemas triangulares inferiores. Verifique seu código para o sistema
  \begin{equation}
    \begin{aligned}
      &-x_1 = 2\\
      &-3x_1 + 2x_2 = -8\\
      &-x_1 + x_2 - x_3 = 0
    \end{aligned}
  \end{equation}
\end{exr}

\begin{exr}\label{exr:sisLinSup}
  Crie sua própria função para a computação da solução de um sistemas triangulares superiores. Verifique seu código para o sistema
  \begin{equation}
    \begin{aligned}
      &2x_1 - x_2 + 2x_3 = 7\\
      &2x_2 - x_3 = -3\\
      &3x_3 = 3
    \end{aligned}
  \end{equation}
\end{exr}

\begin{exr}
  Faça um código para resolver o sistema linear
  \begin{equation}
    \begin{aligned}
      &x_1 - x_2 + 2x_3 = -6\\
      &2x_1 + x_2 - x_3 = 1\\
      &-x_1 + x_2 + x_3 = 0
    \end{aligned}
  \end{equation}
  na sua forma matricial $A\pmb{x} = \pmb{b}$.
  \begin{enumerate}[a)]
  \item Use \lstinline+int gsl_linalg_LU_decomp(gsl_matrix *A, gsl_permutation *p, int *signum)+ para computar a decomposição $A = LU$, onde $A$ é a matriz de coeficientes do sistema.
  \item Use sua função criada no Exercício~\ref{exr:sisLinInf} para resolver $L\pmb{y} = \pmb{b}$, onde $\pmb{b}$ o vetor dos termos constantes do sistema.
  \item Use sua função criada no Exercício~\ref{exr:sisLinSup} para resolver $U\pmb{x} = \pmb{y}$.
  \end{enumerate}
\end{exr}

\begin{exr}
  Faça um código para computar a solução do sistema
  \begin{equation}
    \begin{aligned}
      &2x_1 - x_2 = 0\\
      &x_{i-1} - 6x_i + 4x_{i+1} = \sen(\pi i/[2(n-1)])\\
      &x_{n-1} + x_n = 1
    \end{aligned}
  \end{equation}
  para $i= 2, 3, \dotsc, n-1$, $n\geq 3$. Dica: use o método \href{https://www.gnu.org/software/gsl/doc/html/linalg.html#c.gsl_linalg_solve_tridiag}{\lstinline!gsl_linalg_solve_tridiag!}.
\end{exr}

\section{Elementos da Orientação-a-Objetos}\label{sec_oo}

\badgeConstrucao

% endnotes
\clearpage
\phantomsection
\addcontentsline{toc}{chapter}{Notas}
\theendnotes

%%references
\ifisbook
\clearpage
\phantomsection
\renewcommand\bibname{Referências}
\addcontentsline{toc}{chapter}{\bibname}
\fi

\nocite{*}
\begin{thebibliography}{99}

\bibitem{GNUC}
  The GNU C Reference Manual, \url{https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html}, Novembro, 2021.
  
\bibitem{GSL}
  GNU Scientific Library, \url{https://www.gnu.org/software/gsl/doc/html/index.html}, Novembro, 2021.
  
\bibitem{Soffner}
  Soffner, R.. Algoritmos e Programação em Linguagem C. Editora Saraiva, 2013. ISBN: 978-8502207530. \href{https://bit.ly/45VccHe}{Sabi{+}UFRGS}.

\bibitem{Backes}
  Backes, A.. Linguagem C: Completa e Descomplicada. LTC, 2. ed., 2018. ISBN: 978-8535291063. \href{Sabi{+}UFRGS}{https://bit.ly/46Vk7Wv}.
  
\end{thebibliography}

\end{document}
